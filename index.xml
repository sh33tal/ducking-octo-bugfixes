<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>http://sh33tal.github.io/</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 12 Jun 2015 05:20:03 +0000</lastBuildDate>
    <atom:link href="http://sh33tal.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>My C# Tips</title>
      <link>http://sh33tal.github.io/post/My%20Tips/</link>
      <pubDate>Fri, 12 Jun 2015 05:20:03 +0000</pubDate>
      
      <guid>http://sh33tal.github.io/post/My%20Tips/</guid>
      <description>

&lt;h3 id=&#34;the-null-coalescing-operator:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;The Null Coalescing operator&lt;/h3&gt;

&lt;p&gt;The null-coalescing operator can simplify our If statements when we need to check for the existence of a null value and provide some other default. If we don&amp;rsquo;t use the null-coalescing operator, we typically end up with If statements that look something like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        if (name == null)
        {
            result = &amp;quot;no name provided&amp;quot;;
        }
        else
        {
            result = name;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now Let using the null-coalescing operator.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var name = &amp;quot;Hetal&amp;quot;;

        var result = name ?? &amp;quot;no name provided&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we set a name and then we want to get a result. What we want is if the name is not null then to just use the name. Otherwise, use this default string. The ?? here signify the null-coalescing operator.&lt;/p&gt;

&lt;h3 id=&#34;testing-char-unicode-validity:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Testing char Unicode validity&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s useful to check whether a character is valid or not. To do this, we can use the static GetUnicodeCharacter method of the char struct. To use this method, we pass in a char and we get back a category. To test whether the character is valid, we check this Category is not equal to the OtherNotAssigned category.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var validCharacter = &#39;q&#39;;

        var ucCategory = char.GetUnicodeCategory(validCharacter);

        var isValidUnicode = ucCategory != UnicodeCategory.OtherNotAssigned;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;isValidUnicode is true because at the moment we&amp;rsquo;re comparing the lowercase letter q.&lt;/p&gt;

&lt;p&gt;If we cast from an integer and convert this to a char, we could end up with something that is not a valid Unicode character.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var invalidCharacter = (char) 888;

        ucCategory = char.GetUnicodeCategory(invalidCharacter);

        isValidUnicode = ucCategory != UnicodeCategory.OtherNotAssigned;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The category that we&amp;rsquo;ve got is the OtherNotAssigned category and isValidUnicode is now false. So the GetUnicodeCategory method is a useful one whenever we&amp;rsquo;re dealing with Unicode conversions that may fall outside of the valid set of Unicode values. Unicode categories include other useful things. We can find out whether the categories are currency symbols, enclosing marks, letter number separators, punctation, and a category such as uppercase letters.&lt;/p&gt;

&lt;h3 id=&#34;creating-random-numbers:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Creating random numbers&lt;/h3&gt;

&lt;p&gt;When we create a new random instance without specifying a seed value, it uses the current system time as the seed value. Because the system clock is limited in its level granularity, if we create two random instances close together, they may be initialized with the same seed value and hence will produce the same sequence of numbers. in the example below I&amp;rsquo;ve created two random instances, r1 and r2, and then I simply generated 5 numbers from that random instance. I&amp;rsquo;ve then done the same thing again, but for the r2 instance.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var r1 = new Random();
        var r2 = new Random();

        Debug.WriteLine(&amp;quot;r1 sequence&amp;quot;);
        for (int i = 0; i &amp;lt;5; i++)
        {
            Debug.WriteLine(r1.Next());
        }


        Debug.WriteLine(&amp;quot;r2 sequence&amp;quot;);
        for (int i = 0; i &amp;lt;5; i++)
        {
            Debug.WriteLine(r2.Next());
        }           
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The r1 sequence is identical to the r2 instance, the same for the rest of the numbers in the sequence. This is because the 2 random instances have been created so close together that the same seed value was used from the system clock.&lt;/p&gt;

&lt;p&gt;Below we&amp;rsquo;re still creating effectively a sequence of 10 random numbers, but this time we&amp;rsquo;re just using a single instance of the random class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [TestMethod]
    public void MoreRandomNumber()
    {
        var r1 = new Random();            

        Debug.WriteLine(&amp;quot;r1 sequence&amp;quot;);
        for (int i = 0; i &amp;lt; 5; i++)
        {
            Debug.WriteLine(r1.Next());
        }

        Debug.WriteLine(&amp;quot;more r1 sequence&amp;quot;);
        for (int i = 0; i &amp;lt; 5; i++)
        {
            Debug.WriteLine(r1.Next());
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will produce a better random sequence. The first five numbers here are different from the second five numbers here and this is because we&amp;rsquo;re just using one instance of the random class. If you needed to generate random numbers between method calls then you could have a static random instance that&amp;rsquo;s used by multiple methods.&lt;/p&gt;

&lt;h3 id=&#34;using-tuples-to-reduce-code:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Using Tuples to reduce code&lt;/h3&gt;

&lt;p&gt;Tuples are generic classes that we can use to hold sets of values of potentially different types. There&amp;rsquo;s a couple of different ways we can create tuples. The first is to simply use the constructor. Below I&amp;rsquo;m creating a single element tuple using the new keyword specifying the type of int and giving it a value for the int.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var tupleOneElement = new Tuple&amp;lt;int&amp;gt;(1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can create 2 Element versions. Below is an int and a string&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var tupleTwoElement = new Tuple&amp;lt;int, string&amp;gt;(1, &amp;quot;hello&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and we can keep going all the way up to seven elements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var tupleSevenElement = 
            new Tuple&amp;lt;int, int, int, int, int, int, int&amp;gt;(1, 2, 3, 4, 5, 6, 7);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to hold more than seven elements, we can do this, but the eighth element must be a tuple. Below is 8 elements, 1-7 with the eighth element being its own tuple and we can continue to nest these.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  var tupleEightElement =new Tuple&amp;lt;int, int, int, int, int, int, int, Tuple&amp;lt;string&amp;gt;&amp;gt;(1, 2, 3, 4, 5, 6, 7, new Tuple&amp;lt;string&amp;gt;(&amp;quot;hello&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The static Create method can be used to create Tuples. The Create method takes a list of values. Below we&amp;rsquo;re creating a tuple with an integer, a string, and a DateTime.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var tupleThreeElement = Tuple.Create(42, &amp;quot;hello&amp;quot;, DateTime.Now);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we&amp;rsquo;ve created a tuple, we can access its properties using the .item1 or .item2 properties. If we created a 7 element tuple, we&amp;rsquo;d have item1 through to item7.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var t = Tuple.Create(42, &amp;quot;hello&amp;quot;);

        int age = t.Item1;
        string greeting = t.Item2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we create a tuple, we can&amp;rsquo;t then change the values of the elements as tuples are immutable.&lt;/p&gt;

&lt;p&gt;We can compare tuples. Below are 2 tuples with the same values, 42 and hello.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var t1 = Tuple.Create(42, &amp;quot;hello&amp;quot;);
        var t2 = Tuple.Create(42, &amp;quot;hello&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we use the standard == operator, we get a reference comparison. So, isEqualTuples in this instance will be false as the variable t1 doesn&amp;rsquo;t refer to the same thing as the variable t2.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        // Reference equality

        var isEqualTuples = t1 == t2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to get a value comparison, we can just use the Equals method. This will compare each individual element within each tuple.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        // &amp;quot;value&amp;quot; comparison
        isEqualTuples = t1.Equals(t2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A good use of tuples is to allow us to create composite keys in dictionaries. Below are three tuples and a SortedDictionary.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var t1 = Tuple.Create(1, &amp;quot;z&amp;quot;);
        var t2 = Tuple.Create(2, &amp;quot;a&amp;quot;);
        var t3 = Tuple.Create(1, &amp;quot;a&amp;quot;);

        var d = new SortedDictionary&amp;lt;Tuple&amp;lt;int, string&amp;gt;, string&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The key in the dictionary is a tuple of int, string and the value in the dictionary is just a string. We then add our three tuples&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     d.Add(t1, &amp;quot;this is Tuple t1&amp;quot;);
     d.Add(t2, &amp;quot;this is Tuple t2&amp;quot;);
     d.Add(t3, &amp;quot;this is Tuple t3&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tuples appear in their sorted order. When sorting tuples, the first element is compared. If they are different, then that gives us our sort order. However, if they&amp;rsquo;re the same, then we compare the next element in the tuple. If these are the same, then we&amp;rsquo;d compare the next, and so on.&lt;/p&gt;

&lt;h3 id=&#34;simplify-constructor-overloads:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Simplify constructor overloads&lt;/h3&gt;

&lt;p&gt;Sometimes when we&amp;rsquo;re writing our own classes, we want to provide a number of different overloads for the constructor. Doing so creates some flexibility in how the calling code creates one of the objects.
In the code below, the Person class has three different overloads.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  class Person{
    private readonly string _name;
    private readonly int _age;
    private readonly string _gender;

    private const string DefaultGender = &amp;quot;Male&amp;quot;;
    private const int DefaultAge = 30;     

    public Person(string name)
    {
        _name = name;
        _age = DefaultAge ;
        _gender = DefaultGender;
    }

    public Person(string name, int age)
    {
        _name = name;
        _age = age;
        _gender = DefaultGender;
    }

    public Person(string name, int age, string gender)
    {
        _name = name;
        _age = age;
        _gender = gender;
    }
}

  [TestMethod]
  public void personConstrutors{
       var p1 = new Person(&amp;quot;Lebron&amp;quot;);
       var p1 = new Person(&amp;quot;Kobi&amp;quot;, 35);
       var p1 = new Person(&amp;quot;Sir Charles&amp;quot;, &amp;quot;Male&amp;quot;, 50);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;p1 has some default age and some default gender with the name &amp;ldquo;Lebron&amp;rdquo;.
P2 has the age that we passed, some default gender, and the name that we passed.
p3 has the age, gender, and name that we passed.&lt;/p&gt;

&lt;p&gt;We can simplify this a bit and remove some code. We can do this by effectively calling one constructor from another one by using the This keyword.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  class Person{
    private readonly string _name;
    private readonly int _age;
    private readonly string _gender;

    private const string DefaultGender = &amp;quot;Male&amp;quot;;     
    private const int DefaultAge = 30;     

    public Person(string name)
        : this(name, DefaultAge, DefaultGender)
    {
    }

    public Person(string name, int age)
        : this(name, age, DefaultGender)
    {
    }

    public Person(string name, int age, string gender)
    {
        _name = name;
        _age = age;
        _gender = gender;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chaining of constructors is a way that we can remove some redundant code.&lt;/p&gt;

&lt;h3 id=&#34;static-array-methods:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Static Array Methods&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve got an array of names&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var names = new[] { &amp;quot;Duncan&amp;quot;, &amp;quot;James&amp;quot;, &amp;quot;Bryant&amp;quot;, &amp;quot;Robinson&amp;quot; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a number of static methods of the Array class.&lt;/p&gt;

&lt;h4 id=&#34;make-an-array-readonly:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Make an array ReadOnly&lt;/h4&gt;

&lt;p&gt;If we ever need to provide a read-only view of an array, we can use the Array.AsReadOnly method. This method simply takes an array and returns a ReadOnlyCollection.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   [TestMethod]
    public void ReadonlyCollection()
    {
        var names = new[] { &amp;quot;Duncan&amp;quot;, &amp;quot;James&amp;quot;, &amp;quot;Bryant&amp;quot;, &amp;quot;Robinson&amp;quot; };
        ReadOnlyCollection&amp;lt;string&amp;gt; ro = Array.AsReadOnly(names);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;finding-items-in-an-array:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Finding items in an array&lt;/h4&gt;

&lt;p&gt;To find the index of an item in the array, we can use the BinarySearchmethod or FindIndex method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        int jamesIndex = Array.BinarySearch(names, &amp;quot;James&amp;quot;);

        int jamesIndex = Array.FindIndex(names, x =&amp;gt; x.StartsWith(&amp;quot;James&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there are no matches, then we get a -1 returned. If there&amp;rsquo;s more than one match, we get the index of the first matching item.&lt;/p&gt;

&lt;h4 id=&#34;existence-of-items-in-an-array:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Existence of items in an array&lt;/h4&gt;

&lt;p&gt;Use the Array.Exists method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        bool isDuncanThere = Array.Exists(names, x =&amp;gt; x == &amp;quot;Duncan&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;find-the-last-instance:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Find the last instance&lt;/h4&gt;

&lt;p&gt;Use the Array.FindLastmethod.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        string lastBryant = Array.FindLast(names, x =&amp;gt; x.StartsWith(&amp;quot;Bryant&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;iterate-over-an-array:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Iterate over an array&lt;/h4&gt;

&lt;p&gt;Use theArray.ForEach method. This takes an array and an action to be performed for each element in the array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Array.ForEach(names, x =&amp;gt;
                     {
                      Console.WriteLine(x);
                      C.WriteLine(x.Length);                                         
                     });
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sort-an-array:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Sort an array&lt;/h4&gt;

&lt;p&gt;Use the Array.Sort method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Array.Sort(names);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;test-all-elements-in-the-array-satisfy-some-condition:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Test all elements in the array satisfy some condition.&lt;/h4&gt;

&lt;p&gt;Use the Array.TrueForAllmethod. This takes an array and a predicate that we&amp;rsquo;re testing for.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        bool allNamesStartWithA = Array.TrueForAll(names, x =&amp;gt; x.StartsWith(&amp;quot;A&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This returns false because not every element satisfies the predicate.&lt;/p&gt;

&lt;h4 id=&#34;reverse-an-array:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Reverse an array&lt;/h4&gt;

&lt;p&gt;Use Array.Reverse method to reverse the items in the array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Array.Reverse(names);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we&amp;rsquo;re working with arrays, there&amp;rsquo;s a number of different ways we can copy&lt;/p&gt;

&lt;h4 id=&#34;copying-arrays:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Copying arrays&lt;/h4&gt;

&lt;p&gt;Use instance Clone method.
The Clone method returns an object, so we have to cast to an array of strings.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        string[] shallowCopy = (string[]) names.Clone();

        var originalElementZero = names[0];

        var copyElementZero = shallowCopy[0];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our initial array contains four names. The shallowCopy has the same four names. When working with reference types in our array, we need to be aware that the Clone method creates a shallow copy of each item. This means that each element in the Source and Destination array point to the same place in memory. We can check this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var isSameReference = object.ReferenceEquals(originalElementZero, copyElementZero);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we&amp;rsquo;ve not performed a deep copy here.
When using the Clone method with value types, we get a copy of each value.&lt;/p&gt;

&lt;p&gt;CopyTo method allows us to copy the contents from one array to a Destinationarray. We can specify at which element in the Destination array to start copying to.&lt;/p&gt;

&lt;p&gt;Create an array of six elements of type string and populate the first four elements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var names = new string[6];
        names[0] = &amp;quot;Magic&amp;quot;;
        names[1] = &amp;quot;Thomas&amp;quot;;
        names[2] = &amp;quot;Jordan&amp;quot;;
        names[3] = &amp;quot;Bird&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create another array with another three names.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var otherNames = new[] {&amp;quot;Ewing&amp;quot;,&amp;quot;Pipen&amp;quot;,&amp;quot;Drexler&amp;quot;};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use the CopyTo command to copy from OtherNames array to names array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        otherNames.CopyTo(names, 3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This populates our Destination Names array from element 3. So before we execute the CopyTo command, our Names array contains four names and two null values. Now after the CopyTo has executed, we can see that &amp;ldquo;Ewing&amp;rdquo;, &amp;ldquo;Pipen&amp;rdquo; and &amp;ldquo;Drexler&amp;rdquo; have been copied from the otherNames array to the Names array and we&amp;rsquo;ve started overwriting the Names array at element 3. In this case &amp;ldquo;Bird&amp;rdquo; has been overwritten with &amp;ldquo;Ewing&amp;rdquo; and the original 2 null values have been replaced with &amp;ldquo;Pipen&amp;rdquo; and &amp;ldquo;Drexler&amp;rdquo;. The same rules apply here for reference equality.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var originalEwing = otherNames[0];
        var copiedEwing = names[3];

        var isSameReference =
            object.ReferenceEquals(originalMagic , copied);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that Ewing in the original array points to the same place in memory as the copied Ewing because we&amp;rsquo;re dealing with strings in this example, which are reference types.&lt;/p&gt;

&lt;h5 id=&#34;converting-arrays:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Converting Arrays&lt;/h5&gt;

&lt;p&gt;To convert an array of one type to an array of a different type, we can use the array ConvertAllstatic method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var ints = new[] {1, 2, 3 };

        BigInteger[] bigInts = Array.ConvertAll(ints, x =&amp;gt; new BigInteger(x));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each integer will be converted to a BigInteger. The resulting array now contains three BigIntegers, 1, 2, and 3.&lt;/p&gt;

&lt;h5 id=&#34;constrainedcopy:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;ConstrainedCopy&lt;/h5&gt;

&lt;p&gt;If we want to perform a copy from one array to another, but we want to ensure that the entire copy either succeeds or fails in an atomic fashion, we can use the array ConstrainedCopy method. This method takes the Source array and the start element of the Source array followed by the Destinationarray and the Destination element to start at and the number of elements we want to copy.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var things = new object[] { &amp;quot;Julius&amp;quot;, 1};

        var thingsCopy = new object[2];            

        Array.ConstrainedCopy(things, 0, thingsCopy, 0, 2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code copies from the array of things, which is an array of objects to the array called thingsCopy, which again is an array of objects. So here, each element in the Source array of things is convertible to each element of the Destination array of thingsCopy.&lt;/p&gt;

&lt;p&gt;If we look at the result, we can see indeed that the copy was successful. However, if we declare a new array&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var strings = new string[2];
        things.CopyTo(strings, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is an array of strings so the first element of the Source array, &amp;ldquo;Julius&amp;rdquo;, will be convertible, but the second element, an integer, will not be. So if we execute&lt;/p&gt;

&lt;p&gt;we will get an exception because we can&amp;rsquo;t cast from the integer of the second element to a string. But the first element wiil be populated where as the second element, where this exception occurred, will not be. The Destination strings array is in an inconsistent state.&lt;/p&gt;

&lt;p&gt;This is where the ConstrainedCopy method can be used to handle this situation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var strings = new string[2];
        Array.ConstrainedCopy(things, 0, strings, 0, 2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, we get an exception, but this time if we look at ourDestination array, we can see that the first element is no longer &amp;ldquo;Julius&amp;rdquo; and that&amp;rsquo;s because ConstrainedCopywill either copy all elements successfully or it will roll back the initial state of the Destination array.&lt;/p&gt;

&lt;h3 id=&#34;converting-base-types-to-byte-arrays:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Converting base types to byte arrays&lt;/h3&gt;

&lt;p&gt;If we&amp;rsquo;re working with some of the base types in C#, we can make use of the BitConverter class to convert these to and from arrays of byte values. Sometimes this is useful if we need to get binary representations of values. The BitConverter class contains a static GetByte method.
BitConverter.GetByte
This allows us to pass the value to be converted to a byteArray. The GetBytes method supports Booleans, characters, doubles, floats,integers, longs, shorts, unsigned integers, unsigned longs, and unsigned shorts.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        const float originalFloat = 24.56f;

        byte[] byteArray = BitConverter.GetBytes(originalFloat);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example here, we&amp;rsquo;re just setting up an original Float value, 24.56. We&amp;rsquo;re then using the BitConverter.GetBytes method to create an array of bytes.&lt;/p&gt;

&lt;p&gt;To convert this array of bytes back to the originalFloat value, we can use theBitConverter.To Single method.&lt;/p&gt;

&lt;p&gt;float convertedBack = BitConverter.ToSingle(byteArray, 0);&lt;/p&gt;

&lt;p&gt;The BitConverter also contains a number of methods such as ToBoolean, ToDouble, ToInt16, 32, 64, and so on, to allow us to convert back from an array of bytes to the original value. In addition to providing the array, we also have to tell the method at which byte in the array to start. In the above example, the array only contains the originalFloat, so we tell it to start at the beginning.
So the BitConverter class allows us to get the byte values for some of the basic types. The GetBytes method doesn&amp;rsquo;t allow us to serialize all of the types. For example, it doesn&amp;rsquo;t support DateTimes, but we&amp;rsquo;re still able to convert DateTimes to an array of bytes. The first step is to make use of the DateTimes ToBinary method. The ToBinary method gives us a binary value for the DateTime and gives us a long. Once we have a long, we can then use the BitConverter.GetByte method as this supports long values.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        long originalLong = originalDate.ToBinary();

        byte[] byteArray = BitConverter.GetBytes(originalLong);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So here we get back an array of bytes whuch can use the DateTime.FromBinary method, which expects a long.&lt;/p&gt;

&lt;p&gt;To convert from our array of bytes, we use the BitConverter.ToInt64 method, passing a bytearray that contains an Int64 and again we tell it to start at the beginning of the array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       DateTime convertedBack = DateTime.FromBinary(BitConverter.ToInt64(byteArray, 0));
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>My C# Tips</title>
      <link>http://sh33tal.github.io/post/My%20Tips/</link>
      <pubDate>Fri, 12 Jun 2015 05:20:03 +0000</pubDate>
      
      <guid>http://sh33tal.github.io/post/My%20Tips/</guid>
      <description>

&lt;h3 id=&#34;the-null-coalescing-operator:8c701ccd430ccd5232bee19927928047&#34;&gt;The Null Coalescing operator&lt;/h3&gt;

&lt;p&gt;The null-coalescing operator can simplify our If statements when we need to check for the existence of a null value and provide some other default. If we don&amp;rsquo;t use the null-coalescing operator, we typically end up with If statements that look something like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        if (name == null)
        {
            result = &amp;quot;no name provided&amp;quot;;
        }
        else
        {
            result = name;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now Let using the null-coalescing operator.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var name = &amp;quot;Hetal&amp;quot;;

        var result = name ?? &amp;quot;no name provided&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we set a name and then we want to get a result. What we want is if the name is not null then to just use the name. Otherwise, use this default string. The ?? here signify the null-coalescing operator.&lt;/p&gt;

&lt;h3 id=&#34;testing-char-unicode-validity:8c701ccd430ccd5232bee19927928047&#34;&gt;Testing char Unicode validity&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s useful to check whether a character is valid or not. To do this, we can use the static GetUnicodeCharacter method of the char struct. To use this method, we pass in a char and we get back a category. To test whether the character is valid, we check this Category is not equal to the OtherNotAssigned category.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var validCharacter = &#39;q&#39;;

        var ucCategory = char.GetUnicodeCategory(validCharacter);

        var isValidUnicode = ucCategory != UnicodeCategory.OtherNotAssigned;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;isValidUnicode is true because at the moment we&amp;rsquo;re comparing the lowercase letter q.&lt;/p&gt;

&lt;p&gt;If we cast from an integer and convert this to a char, we could end up with something that is not a valid Unicode character.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var invalidCharacter = (char) 888;

        ucCategory = char.GetUnicodeCategory(invalidCharacter);

        isValidUnicode = ucCategory != UnicodeCategory.OtherNotAssigned;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The category that we&amp;rsquo;ve got is the OtherNotAssigned category and isValidUnicode is now false. So the GetUnicodeCategory method is a useful one whenever we&amp;rsquo;re dealing with Unicode conversions that may fall outside of the valid set of Unicode values. Unicode categories include other useful things. We can find out whether the categories are currency symbols, enclosing marks, letter number separators, punctation, and a category such as uppercase letters.&lt;/p&gt;

&lt;h3 id=&#34;creating-random-numbers:8c701ccd430ccd5232bee19927928047&#34;&gt;Creating random numbers&lt;/h3&gt;

&lt;p&gt;When we create a new random instance without specifying a seed value, it uses the current system time as the seed value. Because the system clock is limited in its level granularity, if we create two random instances close together, they may be initialized with the same seed value and hence will produce the same sequence of numbers. in the example below I&amp;rsquo;ve created two random instances, r1 and r2, and then I simply generated 5 numbers from that random instance. I&amp;rsquo;ve then done the same thing again, but for the r2 instance.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var r1 = new Random();
        var r2 = new Random();

        Debug.WriteLine(&amp;quot;r1 sequence&amp;quot;);
        for (int i = 0; i &amp;lt;5; i++)
        {
            Debug.WriteLine(r1.Next());
        }


        Debug.WriteLine(&amp;quot;r2 sequence&amp;quot;);
        for (int i = 0; i &amp;lt;5; i++)
        {
            Debug.WriteLine(r2.Next());
        }           
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The r1 sequence is identical to the r2 instance, the same for the rest of the numbers in the sequence. This is because the 2 random instances have been created so close together that the same seed value was used from the system clock.&lt;/p&gt;

&lt;p&gt;Below we&amp;rsquo;re still creating effectively a sequence of 10 random numbers, but this time we&amp;rsquo;re just using a single instance of the random class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [TestMethod]
    public void MoreRandomNumber()
    {
        var r1 = new Random();            

        Debug.WriteLine(&amp;quot;r1 sequence&amp;quot;);
        for (int i = 0; i &amp;lt; 5; i++)
        {
            Debug.WriteLine(r1.Next());
        }

        Debug.WriteLine(&amp;quot;more r1 sequence&amp;quot;);
        for (int i = 0; i &amp;lt; 5; i++)
        {
            Debug.WriteLine(r1.Next());
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will produce a better random sequence. The first five numbers here are different from the second five numbers here and this is because we&amp;rsquo;re just using one instance of the random class. If you needed to generate random numbers between method calls then you could have a static random instance that&amp;rsquo;s used by multiple methods.&lt;/p&gt;

&lt;h3 id=&#34;using-tuples-to-reduce-code:8c701ccd430ccd5232bee19927928047&#34;&gt;Using Tuples to reduce code&lt;/h3&gt;

&lt;p&gt;Tuples are generic classes that we can use to hold sets of values of potentially different types. There&amp;rsquo;s a couple of different ways we can create tuples. The first is to simply use the constructor. Below I&amp;rsquo;m creating a single element tuple using the new keyword specifying the type of int and giving it a value for the int.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var tupleOneElement = new Tuple&amp;lt;int&amp;gt;(1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can create 2 Element versions. Below is an int and a string&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var tupleTwoElement = new Tuple&amp;lt;int, string&amp;gt;(1, &amp;quot;hello&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and we can keep going all the way up to seven elements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var tupleSevenElement = 
            new Tuple&amp;lt;int, int, int, int, int, int, int&amp;gt;(1, 2, 3, 4, 5, 6, 7);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to hold more than seven elements, we can do this, but the eighth element must be a tuple. Below is 8 elements, 1-7 with the eighth element being its own tuple and we can continue to nest these.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  var tupleEightElement =new Tuple&amp;lt;int, int, int, int, int, int, int, Tuple&amp;lt;string&amp;gt;&amp;gt;(1, 2, 3, 4, 5, 6, 7, new Tuple&amp;lt;string&amp;gt;(&amp;quot;hello&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The static Create method can be used to create Tuples. The Create method takes a list of values. Below we&amp;rsquo;re creating a tuple with an integer, a string, and a DateTime.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var tupleThreeElement = Tuple.Create(42, &amp;quot;hello&amp;quot;, DateTime.Now);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we&amp;rsquo;ve created a tuple, we can access its properties using the .item1 or .item2 properties. If we created a 7 element tuple, we&amp;rsquo;d have item1 through to item7.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var t = Tuple.Create(42, &amp;quot;hello&amp;quot;);

        int age = t.Item1;
        string greeting = t.Item2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we create a tuple, we can&amp;rsquo;t then change the values of the elements as tuples are immutable.&lt;/p&gt;

&lt;p&gt;We can compare tuples. Below are 2 tuples with the same values, 42 and hello.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var t1 = Tuple.Create(42, &amp;quot;hello&amp;quot;);
        var t2 = Tuple.Create(42, &amp;quot;hello&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we use the standard == operator, we get a reference comparison. So, isEqualTuples in this instance will be false as the variable t1 doesn&amp;rsquo;t refer to the same thing as the variable t2.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        // Reference equality

        var isEqualTuples = t1 == t2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to get a value comparison, we can just use the Equals method. This will compare each individual element within each tuple.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        // &amp;quot;value&amp;quot; comparison
        isEqualTuples = t1.Equals(t2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A good use of tuples is to allow us to create composite keys in dictionaries. Below are three tuples and a SortedDictionary.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var t1 = Tuple.Create(1, &amp;quot;z&amp;quot;);
        var t2 = Tuple.Create(2, &amp;quot;a&amp;quot;);
        var t3 = Tuple.Create(1, &amp;quot;a&amp;quot;);

        var d = new SortedDictionary&amp;lt;Tuple&amp;lt;int, string&amp;gt;, string&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The key in the dictionary is a tuple of int, string and the value in the dictionary is just a string. We then add our three tuples&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     d.Add(t1, &amp;quot;this is Tuple t1&amp;quot;);
     d.Add(t2, &amp;quot;this is Tuple t2&amp;quot;);
     d.Add(t3, &amp;quot;this is Tuple t3&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tuples appear in their sorted order. When sorting tuples, the first element is compared. If they are different, then that gives us our sort order. However, if they&amp;rsquo;re the same, then we compare the next element in the tuple. If these are the same, then we&amp;rsquo;d compare the next, and so on.&lt;/p&gt;

&lt;h3 id=&#34;simplify-constructor-overloads:8c701ccd430ccd5232bee19927928047&#34;&gt;Simplify constructor overloads&lt;/h3&gt;

&lt;p&gt;Sometimes when we&amp;rsquo;re writing our own classes, we want to provide a number of different overloads for the constructor. Doing so creates some flexibility in how the calling code creates one of the objects.
In the code below, the Person class has three different overloads.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  class Person{
    private readonly string _name;
    private readonly int _age;
    private readonly string _gender;

    private const string DefaultGender = &amp;quot;Male&amp;quot;;
    private const int DefaultAge = 30;     

    public Person(string name)
    {
        _name = name;
        _age = DefaultAge ;
        _gender = DefaultGender;
    }

    public Person(string name, int age)
    {
        _name = name;
        _age = age;
        _gender = DefaultGender;
    }

    public Person(string name, int age, string gender)
    {
        _name = name;
        _age = age;
        _gender = gender;
    }
}

  [TestMethod]
  public void personConstrutors{
       var p1 = new Person(&amp;quot;Lebron&amp;quot;);
       var p1 = new Person(&amp;quot;Kobi&amp;quot;, 35);
       var p1 = new Person(&amp;quot;Sir Charles&amp;quot;, &amp;quot;Male&amp;quot;, 50);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;p1 has some default age and some default gender with the name &amp;ldquo;Lebron&amp;rdquo;.
P2 has the age that we passed, some default gender, and the name that we passed.
p3 has the age, gender, and name that we passed.&lt;/p&gt;

&lt;p&gt;We can simplify this a bit and remove some code. We can do this by effectively calling one constructor from another one by using the This keyword.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  class Person{
    private readonly string _name;
    private readonly int _age;
    private readonly string _gender;

    private const string DefaultGender = &amp;quot;Male&amp;quot;;     
    private const int DefaultAge = 30;     

    public Person(string name)
        : this(name, DefaultAge, DefaultGender)
    {
    }

    public Person(string name, int age)
        : this(name, age, DefaultGender)
    {
    }

    public Person(string name, int age, string gender)
    {
        _name = name;
        _age = age;
        _gender = gender;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chaining of constructors is a way that we can remove some redundant code.&lt;/p&gt;

&lt;h3 id=&#34;static-array-methods:8c701ccd430ccd5232bee19927928047&#34;&gt;Static Array Methods&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve got an array of names&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var names = new[] { &amp;quot;Duncan&amp;quot;, &amp;quot;James&amp;quot;, &amp;quot;Bryant&amp;quot;, &amp;quot;Robinson&amp;quot; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a number of static methods of the Array class.&lt;/p&gt;

&lt;h4 id=&#34;make-an-array-readonly:8c701ccd430ccd5232bee19927928047&#34;&gt;Make an array ReadOnly&lt;/h4&gt;

&lt;p&gt;If we ever need to provide a read-only view of an array, we can use the Array.AsReadOnly method. This method simply takes an array and returns a ReadOnlyCollection.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   [TestMethod]
    public void ReadonlyCollection()
    {
        var names = new[] { &amp;quot;Duncan&amp;quot;, &amp;quot;James&amp;quot;, &amp;quot;Bryant&amp;quot;, &amp;quot;Robinson&amp;quot; };
        ReadOnlyCollection&amp;lt;string&amp;gt; ro = Array.AsReadOnly(names);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;finding-items-in-an-array:8c701ccd430ccd5232bee19927928047&#34;&gt;Finding items in an array&lt;/h4&gt;

&lt;p&gt;To find the index of an item in the array, we can use the BinarySearchmethod or FindIndex method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        int jamesIndex = Array.BinarySearch(names, &amp;quot;James&amp;quot;);

        int jamesIndex = Array.FindIndex(names, x =&amp;gt; x.StartsWith(&amp;quot;James&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there are no matches, then we get a -1 returned. If there&amp;rsquo;s more than one match, we get the index of the first matching item.&lt;/p&gt;

&lt;h4 id=&#34;existence-of-items-in-an-array:8c701ccd430ccd5232bee19927928047&#34;&gt;Existence of items in an array&lt;/h4&gt;

&lt;p&gt;Use the Array.Exists method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        bool isDuncanThere = Array.Exists(names, x =&amp;gt; x == &amp;quot;Duncan&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;find-the-last-instance:8c701ccd430ccd5232bee19927928047&#34;&gt;Find the last instance&lt;/h4&gt;

&lt;p&gt;Use the Array.FindLastmethod.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        string lastBryant = Array.FindLast(names, x =&amp;gt; x.StartsWith(&amp;quot;Bryant&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;iterate-over-an-array:8c701ccd430ccd5232bee19927928047&#34;&gt;Iterate over an array&lt;/h4&gt;

&lt;p&gt;Use theArray.ForEach method. This takes an array and an action to be performed for each element in the array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Array.ForEach(names, x =&amp;gt;
                     {
                      Console.WriteLine(x);
                      C.WriteLine(x.Length);                                         
                     });
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sort-an-array:8c701ccd430ccd5232bee19927928047&#34;&gt;Sort an array&lt;/h4&gt;

&lt;p&gt;Use the Array.Sort method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Array.Sort(names);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;test-all-elements-in-the-array-satisfy-some-condition:8c701ccd430ccd5232bee19927928047&#34;&gt;Test all elements in the array satisfy some condition.&lt;/h4&gt;

&lt;p&gt;Use the Array.TrueForAllmethod. This takes an array and a predicate that we&amp;rsquo;re testing for.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        bool allNamesStartWithA = Array.TrueForAll(names, x =&amp;gt; x.StartsWith(&amp;quot;A&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This returns false because not every element satisfies the predicate.&lt;/p&gt;

&lt;h4 id=&#34;reverse-an-array:8c701ccd430ccd5232bee19927928047&#34;&gt;Reverse an array&lt;/h4&gt;

&lt;p&gt;Use Array.Reverse method to reverse the items in the array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Array.Reverse(names);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we&amp;rsquo;re working with arrays, there&amp;rsquo;s a number of different ways we can copy&lt;/p&gt;

&lt;h4 id=&#34;copying-arrays:8c701ccd430ccd5232bee19927928047&#34;&gt;Copying arrays&lt;/h4&gt;

&lt;p&gt;Use instance Clone method.
The Clone method returns an object, so we have to cast to an array of strings.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        string[] shallowCopy = (string[]) names.Clone();

        var originalElementZero = names[0];

        var copyElementZero = shallowCopy[0];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our initial array contains four names. The shallowCopy has the same four names. When working with reference types in our array, we need to be aware that the Clone method creates a shallow copy of each item. This means that each element in the Source and Destination array point to the same place in memory. We can check this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var isSameReference = object.ReferenceEquals(originalElementZero, copyElementZero);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we&amp;rsquo;ve not performed a deep copy here.
When using the Clone method with value types, we get a copy of each value.&lt;/p&gt;

&lt;p&gt;CopyTo method allows us to copy the contents from one array to a Destinationarray. We can specify at which element in the Destination array to start copying to.&lt;/p&gt;

&lt;p&gt;Create an array of six elements of type string and populate the first four elements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var names = new string[6];
        names[0] = &amp;quot;Magic&amp;quot;;
        names[1] = &amp;quot;Thomas&amp;quot;;
        names[2] = &amp;quot;Jordan&amp;quot;;
        names[3] = &amp;quot;Bird&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create another array with another three names.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var otherNames = new[] {&amp;quot;Ewing&amp;quot;,&amp;quot;Pipen&amp;quot;,&amp;quot;Drexler&amp;quot;};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use the CopyTo command to copy from OtherNames array to names array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        otherNames.CopyTo(names, 3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This populates our Destination Names array from element 3. So before we execute the CopyTo command, our Names array contains four names and two null values. Now after the CopyTo has executed, we can see that &amp;ldquo;Ewing&amp;rdquo;, &amp;ldquo;Pipen&amp;rdquo; and &amp;ldquo;Drexler&amp;rdquo; have been copied from the otherNames array to the Names array and we&amp;rsquo;ve started overwriting the Names array at element 3. In this case &amp;ldquo;Bird&amp;rdquo; has been overwritten with &amp;ldquo;Ewing&amp;rdquo; and the original 2 null values have been replaced with &amp;ldquo;Pipen&amp;rdquo; and &amp;ldquo;Drexler&amp;rdquo;. The same rules apply here for reference equality.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var originalEwing = otherNames[0];
        var copiedEwing = names[3];

        var isSameReference =
            object.ReferenceEquals(originalMagic , copied);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that Ewing in the original array points to the same place in memory as the copied Ewing because we&amp;rsquo;re dealing with strings in this example, which are reference types.&lt;/p&gt;

&lt;h5 id=&#34;converting-arrays:8c701ccd430ccd5232bee19927928047&#34;&gt;Converting Arrays&lt;/h5&gt;

&lt;p&gt;To convert an array of one type to an array of a different type, we can use the array ConvertAllstatic method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var ints = new[] {1, 2, 3 };

        BigInteger[] bigInts = Array.ConvertAll(ints, x =&amp;gt; new BigInteger(x));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each integer will be converted to a BigInteger. The resulting array now contains three BigIntegers, 1, 2, and 3.&lt;/p&gt;

&lt;h5 id=&#34;constrainedcopy:8c701ccd430ccd5232bee19927928047&#34;&gt;ConstrainedCopy&lt;/h5&gt;

&lt;p&gt;If we want to perform a copy from one array to another, but we want to ensure that the entire copy either succeeds or fails in an atomic fashion, we can use the array ConstrainedCopy method. This method takes the Source array and the start element of the Source array followed by the Destinationarray and the Destination element to start at and the number of elements we want to copy.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var things = new object[] { &amp;quot;Julius&amp;quot;, 1};

        var thingsCopy = new object[2];            

        Array.ConstrainedCopy(things, 0, thingsCopy, 0, 2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code copies from the array of things, which is an array of objects to the array called thingsCopy, which again is an array of objects. So here, each element in the Source array of things is convertible to each element of the Destination array of thingsCopy.&lt;/p&gt;

&lt;p&gt;If we look at the result, we can see indeed that the copy was successful. However, if we declare a new array&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var strings = new string[2];
        things.CopyTo(strings, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is an array of strings so the first element of the Source array, &amp;ldquo;Julius&amp;rdquo;, will be convertible, but the second element, an integer, will not be. So if we execute&lt;/p&gt;

&lt;p&gt;we will get an exception because we can&amp;rsquo;t cast from the integer of the second element to a string. But the first element wiil be populated where as the second element, where this exception occurred, will not be. The Destination strings array is in an inconsistent state.&lt;/p&gt;

&lt;p&gt;This is where the ConstrainedCopy method can be used to handle this situation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var strings = new string[2];
        Array.ConstrainedCopy(things, 0, strings, 0, 2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, we get an exception, but this time if we look at ourDestination array, we can see that the first element is no longer &amp;ldquo;Julius&amp;rdquo; and that&amp;rsquo;s because ConstrainedCopywill either copy all elements successfully or it will roll back the initial state of the Destination array.&lt;/p&gt;

&lt;h3 id=&#34;converting-base-types-to-byte-arrays:8c701ccd430ccd5232bee19927928047&#34;&gt;Converting base types to byte arrays&lt;/h3&gt;

&lt;p&gt;If we&amp;rsquo;re working with some of the base types in C#, we can make use of the BitConverter class to convert these to and from arrays of byte values. Sometimes this is useful if we need to get binary representations of values. The BitConverter class contains a static GetByte method.
BitConverter.GetByte
This allows us to pass the value to be converted to a byteArray. The GetBytes method supports Booleans, characters, doubles, floats,integers, longs, shorts, unsigned integers, unsigned longs, and unsigned shorts.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        const float originalFloat = 24.56f;

        byte[] byteArray = BitConverter.GetBytes(originalFloat);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example here, we&amp;rsquo;re just setting up an original Float value, 24.56. We&amp;rsquo;re then using the BitConverter.GetBytes method to create an array of bytes.&lt;/p&gt;

&lt;p&gt;To convert this array of bytes back to the originalFloat value, we can use theBitConverter.To Single method.&lt;/p&gt;

&lt;p&gt;float convertedBack = BitConverter.ToSingle(byteArray, 0);&lt;/p&gt;

&lt;p&gt;The BitConverter also contains a number of methods such as ToBoolean, ToDouble, ToInt16, 32, 64, and so on, to allow us to convert back from an array of bytes to the original value. In addition to providing the array, we also have to tell the method at which byte in the array to start. In the above example, the array only contains the originalFloat, so we tell it to start at the beginning.
So the BitConverter class allows us to get the byte values for some of the basic types. The GetBytes method doesn&amp;rsquo;t allow us to serialize all of the types. For example, it doesn&amp;rsquo;t support DateTimes, but we&amp;rsquo;re still able to convert DateTimes to an array of bytes. The first step is to make use of the DateTimes ToBinary method. The ToBinary method gives us a binary value for the DateTime and gives us a long. Once we have a long, we can then use the BitConverter.GetByte method as this supports long values.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        long originalLong = originalDate.ToBinary();

        byte[] byteArray = BitConverter.GetBytes(originalLong);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So here we get back an array of bytes whuch can use the DateTime.FromBinary method, which expects a long.&lt;/p&gt;

&lt;p&gt;To convert from our array of bytes, we use the BitConverter.ToInt64 method, passing a bytearray that contains an Int64 and again we tell it to start at the beginning of the array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       DateTime convertedBack = DateTime.FromBinary(BitConverter.ToInt64(byteArray, 0));
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SOLID Principles</title>
      <link>http://sh33tal.github.io/post/Solid-Principles/</link>
      <pubDate>Sun, 02 Nov 2014 09:14:00 -0700</pubDate>
      
      <guid>http://sh33tal.github.io/post/Solid-Principles/</guid>
      <description>

&lt;p&gt;I want to document things that I have learnt as during my journey from database developer to web developer. One of the most useful and  intersting principle that I have learnt is SOLID. The ultimate aim of SOLID is to produce maintable, flexible and testable code. SOLID encourages a more Object Orientated style preventing code from becoming a mess and hard to debug and extend. I found these principles particular useful as my team are TDD evangelists. I am going to share my learning in this blog.&lt;/p&gt;

&lt;h3 id=&#34;the-single-responsibility-principle:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;The Single Responsibility Principle&lt;/h3&gt;

&lt;p&gt;This represents the &amp;ldquo;S&amp;rdquo; in Solid.&lt;/p&gt;

&lt;h4 id=&#34;definition:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Definition&lt;/h4&gt;

&lt;p&gt;The Single Responsibility Principle states that every object should have a single responsibility, and that responsibility should be entirely encapsulated by the class. My Interpretation of this is there should never be more than one reason for a class to change. Just because you can doesn&amp;rsquo;t mean you should. This relates to the concepts of Cohesion and Coupling. We want to strive for cohesion, but also for loose coupling. So cohesion is basically how strongly related and focused the various responsibilities in a module or class are. And coupling is defined as the degree to which each program module or class relies on each of the other modules. We should strive for low coupling, but high cohesion.&lt;/p&gt;

&lt;h4 id=&#34;responsibilities:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Responsibilities&lt;/h4&gt;

&lt;p&gt;Requirements changes typically map to responsibilities. The more responsibilities a class has, the more likelihood of change. Having multiple responsibilities within a class couples together these responsibilities making it likely that changes in one responsibility will effect or break features that are the other responsibilities of a class. The more classes a change effects, the more likely the change will introduce errors into our system. Thus it&amp;rsquo;s important to try and craft our classes in such a way that the areas that are most likely to change are encapsulated into separate classes with single responsibilities.&lt;/p&gt;

&lt;h3 id=&#34;the-open-closed-principle:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;The Open / Closed Principle&lt;/h3&gt;

&lt;p&gt;The Open/Closed Principle, which represents the &amp;ldquo;O&amp;rdquo; in the solid.
This states that software entities such as classes, modules, functions, etc should be open for extension, but closed for modification. When you extend your software you should not need to go and dig around in its internals just to change its behavior. You should be able to extend it by adding new functionality with new classes, new functions. Without the need to change your existing classes and functions, while still achieving new behavior. That means you shouldn&amp;rsquo;t need to change the source code or the binary code, you shouldn&amp;rsquo;t have to recompile the existing pieces of your application a necessarily to achieve this.
How do we change behavior without changing code? The key is to rely on abstractions. Once we start to rely on abstractions in our code, there is no limit to the number of different ways we can implement that abstraction, and thus no limit to the number of ways we can change the behavior of the code that&amp;rsquo;s using these abstractions. So what do we mean by abstractions? Abstractions include Interfaces, as well as Abstract Base Classes.&lt;/p&gt;

&lt;h3 id=&#34;the-liskov-substitution-principle:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;The Liskov Substitution Principle&lt;/h3&gt;

&lt;p&gt;The &amp;ldquo;L&amp;rdquo; in the solid principles of object oriented development.
This Principle simply states that subtypes must be substitutable for their base types. In general calling code should not know that there is any difference at all between a derived type and its base type.  It&amp;rsquo;s very common to say that a particular class IS-A whatever base class it is, for example one might have an employee class that IS-A contact, that IS-A person, or you might have a square that IS-A shape, or a car that IS-A vehicle. The Liskov Substitution Principle suggests that rather than simply considering whether or not some noun is another noun, you should instead consider whether or not it is substitutable for, that other noun in all situations where one might expect it to be. Invariants are things that have to do with the integrity of your model that your classes represent. So they consist of reasonable assumptions of behavior by clients and by other classes that make use of your class. Frequently unit tests can be used to identify what the expected behavior is, for a given method or class. And these unit tests should fail if that behavior is broken or changed, by a subtype that violates it.
Conforming to the Liskov Substitution Principle allows you to properly use polymorphism in your application and will produce more maintainable code. You should remember that is-substitutable-for is the preferred relationship that you should be looking at when you consider inheritance. Rather than simply that IS-A relationship that&amp;rsquo;s so commonly used.&lt;/p&gt;

&lt;h3 id=&#34;the-interface-segregation-principle:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;The Interface Segregation Principle&lt;/h3&gt;

&lt;p&gt;This represents the letter &amp;ldquo;I&amp;rdquo; in the solid acronym of Principles of object oriented design. And applying it can help you create projects and applications that have fewer hidden dependencies, and are more cohesive and easier to maintain. The Interface Segregation Principle basically states, that clients should not be forced to depend on methods that they do not use. You should prefer small cohesive interfaces, to fat interfaces.
It&amp;rsquo;s important for us to further define what we mean by an Interface. An Interface represents a non implementable type that specifies a public set of methods and properties, that must be implemented by anything that chooses to implement that interface. However it&amp;rsquo;s also the public interface of a class, so any class, any type, whatever it&amp;rsquo;s public interface is, whatever its public methods and properties are, if these are things that are used by some client, and it only requires the use of some small subset of those things, it&amp;rsquo;s possible that you would end up with a better design if you were to segregate that class in some way that makes the client not need to use as much of it.&lt;/p&gt;

&lt;h4 id=&#34;design-smells-and-tips:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Design Smells and Tips&lt;/h4&gt;

&lt;p&gt;So some of the smells that you should be looking for in your code that indicate you might be violating the Interface Segregation Principle include, unimplemented interface methods, whether it&amp;rsquo;s in abstract class or any type of base class, or an actual interface, if you find in your code things where your overriding methods from your base class or your base interface, and then simply throwing a new non implemented exception or doing some other kind of degenerate implementation. You should realize that this is probably violating ISP because clearly the class that&amp;rsquo;s using this implementation is not using this particular method, and therefore its using a smaller subset of the actual interface that&amp;rsquo;s its being forced to depend upon. These violate the Liskov Substitution Principle because now these derived classes will not be substitutable for their base classes when the clients expect for all of these interfaces, the entire interface to be implemented and all the methods to do something useful.
Another smell is when you have a client that references a class, but it only uses a small portion of it. This is very similar to the last smell, but not quite exactly the same. This is more from the client side rather than from the implementation side, when you see this sometimes you can make a facade or some other kind of class, that your class depends on and that makes it so that your not depending upon the larger class which is perhaps more likely to change and break your class. When should we fix violations of the Interface Segregation Principle? Like most of these principles you really only want to address them if there&amp;rsquo;s pain, if there&amp;rsquo;s no pain then there&amp;rsquo;s not really a problem that needs to be attended to and you should continue adding new features, and fixing bugs and generally adding value to your application. However if you find yourself depending on a fat interface that you own and this is causing problems because of the dependencies involved, the best thing to do is create a smaller interface that has just what the client needs, have the fat interface implement this new interface. And then reference the new interface within your client code, ignoring the fat interface now. If you find fat interfaces are problematic, but you don&amp;rsquo;t own them, something that you can do is create a smaller interface with just what you need, and then implement this interface.
So some basic tips for the Interface Segregation Principle, keep your interfaces small, cohesive, and focused. Whenever possible you want to let the client define the interface, because this will ensure that the interface really only includes what the client needs. And also whenever possible package the interface with the client. Alternately you can package the interface in a third assembly that both the client and implementation depend upon, and only as a last resort should you try and package up interfaces with their implementation.&lt;/p&gt;

&lt;p&gt;In summary The Interface Segregation Principle states that you should not force client code to depend on things that it doesn&amp;rsquo;t need. You want to make sure you keep your interfaces lean and focused. Refactor large interfaces so they inherit from smaller interfaces that your client uses.&lt;/p&gt;

&lt;h3 id=&#34;the-dependency-inversion-principle:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;The Dependency Inversion Principle&lt;/h3&gt;

&lt;p&gt;The D in the solid principles of object-oriented design. The Dependency Inversion Principle is one of the most important principles of building object-oriented software&lt;/p&gt;

&lt;h4 id=&#34;definition-1:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Definition&lt;/h4&gt;

&lt;p&gt;So the Dependency Inversion Principle states that high-level modules should not depend on low-level modules. Both should depend on abstractions. Furthermore, abstractions should not depend on details, but rather details should depend on abstractions.&lt;/p&gt;

&lt;h4 id=&#34;what-are-dependencies:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;What are Dependencies&lt;/h4&gt;

&lt;p&gt;If you&amp;rsquo;re writing .net software you have taken a dependency on the .net platform, the .net framework, and more or less on Windows. It&amp;rsquo;s a dependency that you&amp;rsquo;re probably pretty comfortable with and that you don&amp;rsquo;t expect to change too much with the course of your software. However, the dependencies we&amp;rsquo;re talking about with regard to our application design are more low level and things that we are going to expect to possibly change as part of our application during its lifetime. For example, access to Third Party Libraries. These can often be things that will change frequently and, therefore, if possible we want to be able to inject alternate implementations of these Third Party Libraries into our code, unless we&amp;rsquo;re certain that our choice of Third Party Libraries is not like to change for the lifetime of our application. Certainly, our database represents a dependency assuming that our application has one and it&amp;rsquo;s definitely one of the things that you will want to wrap in such a way that it is not an implicit dependency within your code, but rather something that could be injected and replaced. We&amp;rsquo;ll see more about how to do that soon. Other dependencies are less obvious. For example, if your code references the file system, if it uses email, if it sends email or even checks email from a POP mailbox for example, if it uses Web Services or really any kind of network access at all, would be a dependency as well. Now represent further dependencies that might require you to invert in the case of situations where they affect the behavior of your application and there&amp;rsquo;s no way for you to test it unless you run it at certain times of day. Configuration can be a dependency in terms of the files that you use for configuring your application. The new Keyword is itself a possible indication that you&amp;rsquo;ve got a dependency within your application. You want to limit the places in which you allow your application to instantiate new objects, unless they&amp;rsquo;re primitives like strings, for example. And related to that is the use of static methods. Anytime you&amp;rsquo;re calling a static method, you&amp;rsquo;re adding a dependency to your code that cannot easily be separated from the calling code in the case of trying to write a test for it or in the case of wanting to change the way your code works throughout the entire application in one place. If you have static methods sprinkled throughout your code, it&amp;rsquo;s very difficult to change them all through one configuration change or one startup file change. Thread.Sleep can also be a dependency, as well as the use of Random, and it can be very difficult to test code that is supposed to give you random results, so if you specify an interface that you use for generating your random values, then in your test you can override that interface and say, well if the random value is this, then I should expect this result and similarly it allows you to more easily test so-called random data. These are some of the dependencies that you should be aware of. It&amp;rsquo;s certainly not an exhaustive list.&lt;/p&gt;

&lt;h4 id=&#34;traditional-programming:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Traditional Programming&lt;/h4&gt;

&lt;p&gt;Most traditional programming works in such a way that dependencies naturally accrue within the code because the higher-level modules tend to call the lower-level modules and by calling them they also tend to instantiate them as they need them, so it&amp;rsquo;s very typical for you to have, for instance, a user interface application that references some business logic and it might new-up one of those business logic classes, perhaps a customer class or an order class, and do some work with it. And in the course of calling the methods on that class maybe it has to talk to the database or maybe it has to talk to some other sort of infrastructure. Typically that business logic class would then new-up a Data Access component or a logger component or some other kind of class to do its work, and so ultimately, the user interface is depending on the business logic, the business logic is depending on the infrastructure and utility in the Data Access classes. Furthermore, it&amp;rsquo;s often the case that a facade layer is implemented using static methods in order to facilitate a simpler API for those business level methods. Then finally, it&amp;rsquo;s typical that class instantiation and call stack logic is scattered throughout the application. This violates the Single Responsibility Principle because now every class that is deciding who it&amp;rsquo;s collaborators are through the use of static methods or the new keyword to instantiate specific instances with which it wants to work, is now responsible not just for its actual work, but also for determining who it&amp;rsquo;s working with, and these are actually separate responsibilities that the Single Responsibility Principle should dictate that you would want to put into separate classes.&lt;/p&gt;

&lt;h4 id=&#34;class-dependencies:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Class Dependencies&lt;/h4&gt;

&lt;p&gt;When we&amp;rsquo;re talking about class dependencies, our class constructor should require any dependencies that the class actually needs. Classes whose constructors make this very clear have what I would call explicit dependencies, however, classes that do not make this clear have implicit or hidden dependencies. They&amp;rsquo;re lying to you. When they say that you can just new them up without passing them anything, but then they don&amp;rsquo;t work if the database isn&amp;rsquo;t there, that&amp;rsquo;s telling you something that is false. It&amp;rsquo;s telling you that this class would work, but then it&amp;rsquo;s not letting you know about the fact you actually need a database in order to do anything.&lt;/p&gt;

&lt;h4 id=&#34;design-smells:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Design Smells&lt;/h4&gt;

&lt;p&gt;Now let&amp;rsquo;s take a look at some design smells related to the Dependency Inversion Principle. The first one is the simplest, it&amp;rsquo;s simply the use of the new keyword. If you find in your code that you&amp;rsquo;re using the new keyword and newing up actual instantiations of particular instances of classes, rather than interfaces, it&amp;rsquo;s often a sign that you could apply the Dependency Inversion Principle.
Similar to the use of the new keyword is the use of static methods or properties. This can be something as simple as a DateTime.Now that&amp;rsquo;s crept into your code instead of having an actual DateTime passed in or an abstraction such as an iCalendar or an iDateTime interface that supports the Now method that you want to be able to pass in.
The one place where you should use or could use static methods is when they don&amp;rsquo;t actually touch anything other than the parameters that are passed into them. For example, if you had a static method that added two numbers together and it took in those numbers as parameters, there would be no problem with that because it&amp;rsquo;s not going to cause any sort of a dependency problem, but if you have a static method that instantiates other classes and those classes might have dependencies of their own, now that&amp;rsquo;s something that is going to likely cause you problems when it comes time to test.&lt;/p&gt;

&lt;h4 id=&#34;where-to-instantiate:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Where to Instantiate&lt;/h4&gt;

&lt;p&gt;If we&amp;rsquo;re not instantiating our objects, where do we insatiate them, you know, somewhere we have to do this. So typically what happens when you apply Dependency Injection is you get many small interfaces, which is good, because each one of them is very cohesive, they&amp;rsquo;re loosely coupled to one another, they have the Single Responsibility Principle, they follow the Interface Segregation Principle, but at some point you have to actually create these objects. There&amp;rsquo;s a couple of different choices for this.
The first one is you can create a default constructor that then inherits from your constructor that actually takes in the interfaces and provides a default implementation of each of those interfaces. This is sometimes poor man&amp;rsquo;s dependency injection or poor man&amp;rsquo;s IoC. IoC means Inversion of Control. The other option is to manually instantiate everything in your application startup routine or main() method. In a web app this could be an application start in the global.asax and another option is to use an IoC container, which does the same thing typically in the main or startup method, but it has a bunch of features that it supports so that you can wire these things up in an intelligent fashion and go to one place and see how your object graph is going to be set up for your application.&lt;/p&gt;

&lt;h4 id=&#34;ioc-containers:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;IoC Containers&lt;/h4&gt;

&lt;p&gt;So, IoC containers or Inversion of Control Containers are responsible for object graph instantiation. They&amp;rsquo;re initiated when the application begins and typically they either use code or configuration, such as an XML file to determine what is going to be set up to be used whenever an interface is called for. Managed interfaces and implementations to be used are registered with the container, so for instance, you might have in your container something that says you want to register IPrintService and say that anywhere I see an object that requires IPrintService, I want to use a new instance of PrintService. Dependencies on these interfaces are then resolved either at application startup or at runtime. You can call an IoC Resolve method that will go and find whatever the instance is that&amp;rsquo;s mapped to that interface at runtime or you can have a container that automatically is able to create the dependency graph for a given class by using its constructor. Typically the constructor that has the most parameters is the one that we&amp;rsquo;ll use.
Sometimes it&amp;rsquo;s necessary to create a factory class that is able to create your class for you and then register the factory class and its dependencies with your IoC Container.&lt;/p&gt;

&lt;h4 id=&#34;interested-in-more-here-are-more-great-resources:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Interested in more? Here are more great resources&lt;/h4&gt;

&lt;p&gt;Agile Principles, Patterns, and Practices book by Robert C. Martin and Micah Martin [&lt;a href=&#34;http://amzn.to/agilepppcsharp&#34;&gt;http://amzn.to/agilepppcsharp&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Martin Fowler&amp;rsquo;s article on dependency injection
&lt;a href=&#34;http://www.martinfowler.com/articles/injection.html&#34;&gt;http://www.martinfowler.com/articles/injection.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>