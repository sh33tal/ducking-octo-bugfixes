<!doctype html>
<html lang="en">
  <head>    
    <title>Hey, It's Alex - SOLID Principles</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

    
    <link href="http://localhost:1313/bootstrap/css/bootstrap.2.2.2.min.css" rel="stylesheet">
    <link href="http://localhost:1313/bootstrap/css/bootstrap-responsive.css" rel="stylesheet">     
    <link href="http://localhost:1313/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="http://localhost:1313/css/ss-social-circle/ss-social-circle.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href='http://fonts.googleapis.com/css?family=Lato:300|Source+Code+Pro:400,700|Quattrocento+Sans:400,400italic,700,700italic' rel='stylesheet' type='text/css'>
    <link href="http://localhost:1313/css/fonts.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link rel="shortcut icon" href="http://localhost:1313/images/alex-normand.ico"> 
    <link rel="apple-touch-icon" href="http://localhost:1313/images/alex-normand.png">
    <link rel="canonical" href="http://localhost:1313/post/Solid-Principles/">

    
    <link href="http://localhost:1313/rss.xml" type="application/atom+xml" rel="alternate" title="">    

  </head>
  <body>    
    <div class="brand">      
      <div class="container">    
          <a href="http://hetalPatel.net"><h1><b>Hetal</b>!</h1></a>              
          <h2 class="subtitle">Innovating through Software</h2>
          <ul class="social-links">
            <li><a href="http://flickr.com/photos/" class="ss-icon ss-social-circle">flickr</a></li>      
            <li><a href="http://facebook.com" class="ss-icon ss-social-circle">facebook</a></li>                            
            <li>&nbsp;</li>
            <li><a href="https://github.com/sh33tal/github.io" class="ss-icon ss-social-circle">github</a></li>            
            <li><a href="https://mobile.twitter.com" class="ss-icon ss-social-circle">twitter</a></li>                         
            <li>&nbsp;</li>            
            <li><a href="http://localhost:1313/index.xml" class="ss-icon ss-social-circle">rss</a></li>
          </ul>
      </div>      
    </div>

<div class="container">
  <div class="content">

    <div class="row-fluid post-full">
      <div class="container content">  
       
      <h1>SOLID Principles <span class="date">[November 2 2014]</span></h1>

       <div class="post content">
        <p>The Single Responsibility Principle</p>

<p>Definition</p>

<p>The Single Responsibility Principle is defined on Wikipedia to state that every object should have a single responsibility, and that responsibility should be entirely encapsulated by the class. My Interpretation of this is there should never be more than one reason for a class to change. Just because you can doesn&rsquo;t mean you should. This relates to the concepts of Cohesion and Coupling. We want to strive for cohesion, but also for loose coupling. So cohesion is basically how strongly related and focused the various responsibilities in a module or class are. And coupling is defined as the degree to which each program module or class relies on each of the other modules. We should strive for low coupling, but high cohesion.</p>

<p>Responsibilities</p>

<p>Requirements changes typically map to responsibilities. The more responsibilities a class has, the more likelihood of change. Having multiple responsibilities within a class couples together these responsibilities making it likely that changes in one responsibility will effect or break features that are the other responsibilities of a class. The more classes a change effects, the more likely the change will introduce errors into our system. Thus it&rsquo;s important to try and craft our classes in such a way that the areas that are most likely to change are encapsulated into separate classes with single responsibilities.</p>

<p>The Open / Closed Principle</p>

<p>The Open/Closed Principle, which represents the &ldquo;O&rdquo; in the solid.
This states that software entities such as classes, modules, functions, etc should be open for extension, but closed for modification. When you extend your software you should not need to go and dig around in its internals just to change its behavior. You should be able to extend it by adding new functionality with new classes, new functions. Without the need to change your existing classes and functions, while still achieving new behavior. That means you shouldn&rsquo;t need to change the source code or the binary code, you shouldn&rsquo;t have to recompile the existing pieces of your application a necessarily to achieve this.
How do we change behavior without changing code? The key is to rely on abstractions. Once we start to rely on abstractions in our code, there is no limit to the number of different ways we can implement that abstraction, and thus no limit to the number of ways we can change the behavior of the code that&rsquo;s using these abstractions. So what do we mean by abstractions? Abstractions include Interfaces, as well as Abstract Base Classes.</p>

<p>The Liskov Substitution Principle</p>

<p>The &ldquo;L&rdquo; in the solid principles of object oriented development.
This Principle simply states that subtypes must be substitutable for their base types. In general calling code should not know that there is any difference at all between a derived type and its base type.  It&rsquo;s very common to say that a particular class IS-A whatever base class it is, for example one might have an employee class that IS-A contact, that IS-A person, or you might have a square that IS-A shape, or a car that IS-A vehicle. The Liskov Substitution Principle suggests that rather than simply considering whether or not some noun is another noun, you should instead consider whether or not it is substitutable for, that other noun in all situations where one might expect it to be. It is important when we talk about the Liskov Substitution Principle, is this concept of invariants. Invariants are things that have to do with the integrity of your model, that your classes represent. So they consist of reasonable assumptions of behavior by clients. By other classes that make use of your class. Frequently unit tests can be used to identify what the expected behavior is, for a given method or class. And these unit tests should fail if that behavior is broken or changed, by a subtype that violates it.
In order to follow the Liskov Substitution Principle, derived classes must not violate any of the constraints to find, or assume by clients of their base classes.</p>

<p>LSP Design Smells</p>

<p>Here are a few of the smells that you should look for in your code that could be indicators of a Liskov Substitution Principle violation. In this case we are iterating over a collection of a particular base type, in this case employee. And now we&rsquo;re going to test to see if that employee is a manager, and if that&rsquo;s the case we&rsquo;ll go ahead and call PrintManager, otherwise we&rsquo;ll call PrintEmployee. You can imagine that as we added additional classes of employees we might have to further break up this if statement and add additional cases to it, thus making our code more and more difficult to maintain. It would be better if the manager knew how to print itself or if the PrintManager were able to do the work within a single print method; a regardless of which type the employee was, so this if logic could be removed. Another smell that you&rsquo;ll find is if you have a child type that inherits from a base class or interface, but does not fully implement that interface. So in this case we have an abstract base class called base, which has methods one and two, and then we have this class child, that&rsquo;s decided that it really only wants to implement method two, and it&rsquo;s going to leave method one throwing and exception. This kind of thing is fairly common; it can cause issues if clients of your code are expecting you to have fully implemented the interface, and in fact you&rsquo;ve only implemented it partially. If you control all the codes yourself this may not be an issue in your case, but it is something to keep and eye on and be aware of. And it&rsquo;s something also that you might consider adding a unit test for, just to prove that you do in fact expect this not implemented exception. So that a user of your interface will or your actual implementation will know that that&rsquo;s expected behavior. Another thing that can help fix this kind of issue is if you follow the interface segregation principle, which we&rsquo;ll cover in a later episode. The interface segregation principle suggests that you use smaller well factored interfaces that are suited to the client code, rather than larger interfaces than necessary. And so if this were the case where in fact you only needed method two of this base class, you could refactor that base class so that it only gave you the methods that you needed. And specify interface, either a base class or an actual C# interface type that would only include the methods and fields that you require. Let&rsquo;s look at how we can refactor our shape example in order to achieve a better design.</p>

<p>Refactoring to a Better Design</p>

<p>Recalled in our first design, we were unable to calculate the area of a rectangle correctly because, when we passed it a rectangle that was actually a square, it treated the object as if it were square and set both the sides to the same value. Then we considered the lack of inheritance version, where we created a new class called shape, that square and rectangle both derived from. So we broke the IS-A relationship between square and rectangle and replaced it with one, that said that both a rectangle and a square are a shape. However in this case we didn&rsquo;t tweak it quite far enough because we didn&rsquo;t move the behavior of area into that abstract class, and therefore we weren&rsquo;t able to use it polymorphically. But instead we had this nasty smell here where we have to check the type of each one, and then call it&rsquo;s particular area method. We can fix both of these problems by applying a little bit of intelligence to our design, and simply creating that abstract area method on shape. Now that we have that method we can implement it via override, on both rectangle and square. And then were able to run those same tests that we saw before. Here we have one where we take a shape from a rectangle and we expect to get back 20. And in this case we do, and in likewise if we take a list of shapes and we deal with it polymorphically, by enumerating through it, our code is much simpler now. There is no if then logic here at all, we are simply adding up each shapes area, and we&rsquo;re not asking each shape for its height and its width, or its side length, or whatever by some third party calculating code. Instead we just are delegating to that shape and say, calculate your area, let me know what it is. If we run this we will also see that it&rsquo;s now working. So by applying the refactoring such that we take rectangle and square and break them apart so that square no longer is a rectangle, since they are not substitutable for one another, and then moving that behavior into shapes such that we can access it polymorphically on each object itself. We&rsquo;re able to get a design that now follows the Liskov Substitution Principle, and also is going to follow the Open/Closed Principle because we&rsquo;ll be able to add additional shapes and add them to this collection and not have to touch this code that calculates the area of multiple shapes. So when should you take the time to look for and fix Liskov Substitution Principle violation? If you notice obvious smells like the one I just showed, either where you&rsquo;re doing if then checks within a polymorphic enumeration of a collection of types. Or where your inheriting from a type or interface and not fully implementing it. In either one of those cases you may want to consider fixing that violation, by using a better interface or simply fully implementing it, or refactoring your code such that a different base class is used, that does in fact offer substitutability. Otherwise you can use the same rules as for the Open/Closed Principle, which is that if you find yourself having to change the code more than once or two times, then it&rsquo;s time to refactor it. Such that it satisfies Open/Closed Principle and also therefore the Liskov Substitution Principle.</p>

<p>Tips</p>

<p>A couple of last tips, remember tell, don&rsquo;t ask. You should prefer not to interrogate objects about there internal state. Rather if you find yourself doing that it&rsquo;s a good idea usually to move that behavior into the object in question. Or possibly extract out and object that has the state and the behavior collected together. Rather than asking you know, let me know this property, let me know that property, let me know the other property because I want to do some operation on them. You should just tell the object, run this operation, and it should use its own internal state to do so. You should also consider the refactoring to a new base class, when you have two types that seem related, but you are not able to substitute them one for another as we saw with the square and the rectangle. In that case you can create a third class that does in fact allow each of them to be substituted, and move both of the base classes such that they derive from this new base class.</p>

<p>Summary</p>

<p>To summarize, conformance to the Liskov Substitution Principle allows you to properly use polymorphism in your application and will produce more maintainable code. You should remember that is-substitutable-for is the preferred relationship that you should be looking at when you consider inheritance. Rather than simply that IS-A relationship that&rsquo;s so commonly used. Some of the related principles to the Liskov Substitution Principle include polymorphism and inheritance, of course. As well as two other solid principles, the Interface Segregation Principle and the Open/Closed Principle.</p>

<p>The Interface Segregation Principle</p>

<p>This represents the letter &ldquo;I&rdquo; in the solid acronym of Principles of object oriented design. And applying it can help you create projects and applications that have fewer hidden dependencies, and are more cohesive and easier to maintain. The Interface Segregation Principle basically states, that clients should not be forced to depend on methods that they do not use. You should prefer small cohesive interfaces, to fat interfaces.
It&rsquo;s important for us to further define what we mean by an Interface. An Interface represents a non implementable type that specifies a public set of methods and properties, that must be implemented by anything that chooses to implement that interface. However it&rsquo;s also the public interface of a class, so any class, any type, whatever it&rsquo;s public interface is, whatever its public methods and properties are, if these are things that are used by some client, and it only requires the use of some small subset of those things, it&rsquo;s possible that you would end up with a better design if you were to segregate that class in some way that made it so the client didn&rsquo;t need to use as much of it.
Design Smells and Tips</p>

<p>So some of the smells that you should be looking for in your code that indicate you might be violating the Interface Segregation Principle include, unimplemented interface methods, whether it&rsquo;s in abstract class or any type of base class, or an actual interface, if you find in your code things where your overriding methods from your base class or your base interface, and then simply throwing a new non implemented exception or doing some other kind of degenerate implementation. You should realize that this is probably violating ISP because clearly the class that&rsquo;s using this implementation is not using this particular method, and therefore its using a smaller subset of the actual interface that&rsquo;s its being forced to depend upon. Remember to that these violate the Liskov Substitution Principle because now these derived classes will not be substitutable for their base classes when the clients expect for all of these interfaces, the entire interface to be implemented and all the methods to do something useful. Another smell is when you have a client that references a class, but it only uses a small portion of it. This is very similar to the last smell, but not quite exactly the same. This is more from the client side rather than from the implementation side, when you see this sometimes you can make a façade or some other kind of class, that your class depends on and that makes it so that your not depending upon the larger class which is perhaps more likely to change and break your class. When should we fix violations of the Interface Segregation Principle? Like most of these principles you really only want to address them if there&rsquo;s pain, if there&rsquo;s no pain then there&rsquo;s not really a problem that needs to be attended to and you should continue adding new features, and fixing bugs and generally adding value to your application. However if you find yourself depending on a fat interface that you own and this is causing problems because of the dependencies involved, the best thing to do is create a smaller interface that has just what the client needs, have the fat interface implement this new interface. And then reference the new interface within your client code, ignoring the fat interface now. If you find fat interfaces are problematic, but you don&rsquo;t own them, something that you can do is create a smaller interface with just what you need, and then implement this interface, that implements the full interface.
So some basic tips for the Interface Segregation Principle, keep your interfaces small, cohesive, and focused. Whenever possible you want to let the client define the interface, because this will ensure that the interface really only includes what the client needs. And also whenever possible package the interface with the client. Alternately you can package the interface in a third assembly that both the client and implementation depend upon, and only as a last resort should you try and package up interfaces with their implementation.</p>

<p>Summary</p>

<p>So to summarize the Interface Segregation Principle states that you should not force client code to&mdash; to depend on things that it doesn&rsquo;t need. You want to make sure you keep your interfaces lean and focused. Refactor large interfaces so they inherit from smaller interfaces that your client uses. There&rsquo;s some related fundamentals here including polymorphism, inheritance, the Liskov Substitution Principle and the façade pattern.</p>

<p>The Dependency Inversion Principle
Introduction</p>

<p>The D in the solid principles of object-oriented design. The Dependency Inversion Principle is one of the most important principles of building object-oriented software</p>

<p>Definition</p>

<p>So the Dependency Inversion Principle states that high-level modules should not depend on low-level modules. Both should depend on abstractions. Furthermore, abstractions should not depend on details, but rather details should depend on abstractions.</p>

<p>What are Dependencies</p>

<p>So before we go any further talking about dependency inversion, we should consider what exactly are dependencies? Obviously, if you&rsquo;re writing .net software you have taken a dependency on the .net platform, the .net framework, and more or less on Windows unless you&rsquo;re developing for Mono, and this is something that is not, you know, within the scope of dependency inversion per se, it&rsquo;s a dependency that you&rsquo;re probably pretty comfortable with and that you don&rsquo;t expect to change too much with the course of your software. However, the dependencies we&rsquo;re talking about with regard to our application design are more low level and things that we are going to expect to possibly change as part of our application during its lifetime. For example, access to Third Party Libraries. These can often be things that will change frequently and, therefore, if possible we want to be able to inject alternate implementations of these Third Party Libraries into our code, unless we&rsquo;re certain that, you know, our choice of Third Party Libraries is not like to change for the lifetime of our application. Certainly, our database represents a dependency assuming that our application has one and it&rsquo;s definitely one of the things that you will want to wrap in such a way that it is not an implicit dependency within your code, but rather something that could be injected and replaced. We&rsquo;ll see more about how to do that soon. Other dependencies are less obvious. For example, if your code references the file system, if it uses email, if it sends email or even checks email from a POP mailbox for example, if it uses Web Services or really any kind of network access at all, would be a dependency as well. Any sort of system resources, even things like just the clock that you might access via DateTime.Now represent further dependencies that might require you to invert in the case of situations where they affect the behavior of your application and there&rsquo;s no way for you to test it unless you run it at certain times of day. Configuration can be a dependency in terms of the files that you use for configuring your application. The new Keyword is itself a possible indication that you&rsquo;ve got a dependency within your application. You want to limit the places in which you allow your application to instantiate new objects, unless they&rsquo;re primitives like strings, for example. And related to that is the use of static methods. Anytime you&rsquo;re calling a static method, you&rsquo;re adding a dependency to your code that cannot easily be separated from the calling code in the case of trying to write a test for it or in the case of wanting to change the way your code works throughout the entire application in one place. If you have static methods sprinkled throughout your code, it&rsquo;s very difficult to change them all through one configuration change or one startup file change. Thread.Sleep can also be a dependency, as well as the use of Random, and it can be very difficult to test code that is supposed to give you random results, so if you specify an interface that you use for generating your random values, then in your test you can override that interface and say, well if the random value is this, then I should expect this result and similarly it allows you to more easily test so-called random data. These are some of the dependencies that you should be aware of. It&rsquo;s certainly not an exhaustive list, but I think I&rsquo;ve covered most of the major ones that you&rsquo;ll typically find in a .NET business application.</p>

<p>Traditional Programming</p>

<p>Most traditional programming works in such a way that dependencies naturally accrue within the code because the higher-level modules tend to call the lower-level modules and by calling them they also tend to instantiate them as they need them, so it&rsquo;s very typical for you to have, for instance, a user interface application that references some business logic and it might new-up one of those business logic classes, perhaps a customer class or an order class, and do some work with it. And in the course of calling the methods on that class maybe it has to talk to the database or maybe it has to talk to some other sort of infrastructure. Typically that business logic class would then new-up a Data Access component or a, you know, logger component or some other kind of class to do its work, and so ultimately, the user interface is depending on the business logic, the business logic is depending on the infrastructure and utility in the Data Access classes. Furthermore, it&rsquo;s often the case that a façade layer is implemented using static methods in order to facilitate a simpler API for those business level methods. It&rsquo;s much simpler for the business logic method to be able to call, you know, SaveCustomer on a Data Access layer static method than for it to implement 20 lines of ADO.NET code itself, so these can also represent dependencies that can be very tricky to extract out of your application. Then finally, it&rsquo;s typical that class instantiation and call stack logic is scattered throughout the application. This violates the Single Responsibility Principle because now every class that is deciding who it&rsquo;s collaborators are through the use of static methods or the new keyword to instantiate specific instances with which it wants to work, is now responsible not just for its actual work, but also for determining who it&rsquo;s working with, and these are actually separate responsibilities that the Single Responsibility Principle should dictate that you would want to put into separate classes.</p>

<p>Class Dependencies</p>

<p>When we&rsquo;re talking about class dependencies, we want to be honest. That means that our class constructor should require any dependencies that that class actually needs. Classes whose constructors make this very clear have what I would call explicit dependencies, however, classes that do not make this clear have implicit or hidden dependencies. They&rsquo;re lying to you. When they say that you can just new them up without passing them anything, but then they don&rsquo;t work if the database isn&rsquo;t there, that&rsquo;s telling you something that is false. It&rsquo;s telling you that this class would work, but then it&rsquo;s not letting you know about the fact that oh, by the way, I actually needed a database in order to do anything. So, for example, here&rsquo;s a class called HelloWorldHidden that has a hidden dependency on the system clock. And so it&rsquo;ll work a certain way in the morning and another way in the afternoon, and another way in the evening, but there&rsquo;s no way for you to alter that dependency. In this case, it&rsquo;s violating the Open/Closed Principle in that if you wanted to change the logic for the dates or the times of day when it does its thing or if you wanted to be able to test it in some way that lets you run all three paths through the method without having to run your tests at different times of day, you would have a hard time doing so. So your classes should instead declare what it is that they need. For instance, with the HelloWorld example, we need a DateTime in order for us to determine which greeting to pass back. We could pass in a DateTime through the constructor or if we wanted to, and it was only being used for one method, we could pass it into the method itself. If we don&rsquo;t want to pass in a particular value object like a DateTime, we could pass in an interface that knows how to return DateTimes, such as an iCalendar that perhaps implements the Now method. And then we could write an implementation of the iCalendar interface that used the System.DateTime.Now implementation by default, but then when we are writing our tests we could use whatever implementation of that we wanted and we could have an afternoon iCalendar that always returned 2:00 p.m., for example, and we could use that in our test to verify that we received Good afternoon whenever we passed in the afternoon calendar implementation.</p>

<p>Demo</p>

<p>Let&rsquo;s look at a simple demo showing how violating the Dependency Inversion Principle can cause problems in your application. In this example, we&rsquo;re going to look at a simple ecommerce application which includes an Order class that represents the customer&rsquo;s order. An Order class has a Checkout method which takes in a shopping cart. The shopping cart has some items in it that the user is purchasing. We have some paymentDetails that will have values such as credit card or cash, and we have an option for whether or not we want to notify the customer when their order has checked out. If we look at the logic for this, we can see that when we have a credit card payment type we&rsquo;re going to charge the card. In any event, we&rsquo;re going to reserve some inventory and if the customer has requested it, we will notify the customer. As it stands here, we see that there are no explicit dependencies being set in the constructor for the Order class. Nor are there any implicit dependencies in this method that would be shown with a static method call or a new instance of a particular implementation. However, when we start to drill down into these methods that it&rsquo;s calling, for instance, NotifyCustomer, you can see that we do, in fact, have dependencies on MailMessage and SmtpClient, DateTime.Now, which is a static method, as well as a Logger static method for this error method here that they are using for error handling. Similarly, the inventory reservation method uses an inventory system that it instantiates and ChargeCard, likewise, uses a new PaymentGateway. So the dependencies in this class include the PaymentGateway, the InventorySystem, the SmtpClient and MailMessage classes, the Logger, as well as DateTime.Now. We&rsquo;ll be able to find a lot of these dependencies using the Architecture, Generate Dependency Graph, By Class menu item in Visual Studio 2010, assuming that you have the correct version. And if you do that, you&rsquo;ll get something that looks similar to this, which will show you all the class level dependencies. It won&rsquo;t show you the static methods. So you&rsquo;ll see here that we&rsquo;re depending on PaymentDetails, Cart, Logger, OrderItem, etc. The only static method it&rsquo;s not showing is the DateTime.Now. Our Logger method is, in fact, shown here. In fact, it&rsquo;s not going to show you anything that&rsquo;s in the framework, it&rsquo;s only going to show you classes that are defined within your project with the settings that I&rsquo;ve used. So what&rsquo;s the problem here? The issue is that if we want to try and test the Order class, it&rsquo;s going to be difficult to inject some of these classes that it requires. If we look at our testClass, we have two tests written so far. We&rsquo;ve named our class OrderCheckoutShould, and that lets us use sort of a sentence structure when we say these tests so we can say OrderCheckoutShould NotFailWithNoItemsNoNotificationNoCreditCard. So we set it up with a new Order, a new Cart, paymentDetails of cash and we set the NotifyCustomer to False. When we run this, we don&rsquo;t have any real indication of success or failure except for the fact that we assumed that if we didn&rsquo;t get an exception it must have worked, because our method is a Void method. And so we can run this one test and it does, in fact, pass when we have nothing to do and no items to do it with. The next one is that we don&rsquo;t want it to fail when we have no items, but we do have notification and we still have NoCreditCard. So at this point, we&rsquo;ve set a CustomerEmail to this bogus someone@nowhere.com and we specified shouldNotifyCustomer to true. When we run this test, however, we get an exception because I&rsquo;m running this on my developer machine and I don&rsquo;t actually have an SMTP Server running so if we view these test results, we&rsquo;ll see that it was a System.Net.WebException. Unable to connect to the remote server and it was unable to make a connection to port 25 of local host when it tried to send the message, and if we look at the Stack Trace, you&rsquo;ll see that this is all SmtpClient trying to send this MailMessage. So at that point I&rsquo;m pretty much stuck. I&rsquo;ve got two options. I can come into my cart should method and I can start doing things like creating a fake SMTP message, I can go into my order and I can say something like, you know, if I&rsquo;m in test mode, don&rsquo;t actually send my message. There&rsquo;s various hacks I can do to try and get around this. There&rsquo;s even a handy tool that maybe you&rsquo;ll want to use sometime called smtp4dev that you can use. You can download this from CodePlex actually and it&rsquo;ll sit there and listen on port 25 on your dev machine and then if you go and run tests like this one, you&rsquo;ll see it flashes and shows you the message that you received. So here&rsquo;s my order details for instance. And if you completely shut it down, minimize it, and rerun your tests, it&rsquo;ll pop up a little toast message here that shows you that a message was received. So, this will still let you test your emails with this particular thing, and similarly, if this was a database access I could write some kind of a test database that I could use if this were talking to my PaymentGateway and my PaymentGateway supports some kind of, you know, fake credentials that I can pass it that&rsquo;ll give me back some kind of data. There&rsquo;s all kinds of ways that I can do some sort of integration test that really does use the implementation that I expect to use in production. But having to put together and glue together all this infrastructure, just to be able to test the logic of my order, to be able to say that, you know, really I just want to know that when NotifyCustomer is true, that this NotifyCustomer method is called. I don&rsquo;t care about the details of it. I don&rsquo;t care if it&rsquo;s notifying him with an email or with an SMS text or if somebody is running down the hall to let them know that their cart happened to have been processed. I just care that when that flag is set, this method is called, and right now, because of the tight coupling of the Order class to these dependencies, the MailMessage and the SmtpClient, I have no way of testing that and that&rsquo;s causing me a lot of pain when I want to be able to write some tests to show that this is really doing what I expect it to do.</p>

<p>The Problem</p>

<p>The problem with our Order class is that it has a lot of hidden dependencies. It&rsquo;s depending on MailMessage, SmtpClient, the InventorySystem, the PaymentGateway, a Logger, and DateTime.Now. And the result is that we have a class that has very tight coupling, there&rsquo;s no easy way to change any of these implementation details, so this is an Open/Closed principle violation. The only way we can change how Order works is to go in and actually change its code, and it all ends up being very difficult to test. So let&rsquo;s talk about a particular technique that we can use to make this easier. Dependency injection is a technique that&rsquo;s used to allow calling code to inject the dependencies that a class needs when it is instantiated. This also goes by the term of the Hollywood Principle, which is basically, Don&rsquo;t call us; we&rsquo;ll call you. So instead of our class calling SmtpClient, it could say that it needs some kind of a notification service that knows how to do notification and it will go ahead and call that, but it doesn&rsquo;t need to instantiate it itself. Now the term dependency injection or DI has three primary techniques that I want to talk about here. The first one is Constructor Injection, the second is Property Injection or Setter Injection, and the third one is Parameter Injection. There are other methods that exist both for Dependency Injection, as well as to solve the general problem of the dependencies that exist when a class knows about the things that it&rsquo;s newing up. One of those is called service location, but those are beyond the scope of this particular module. So the first type of dependency injection is called Constructor Injection, and this is an instance of the Strategy Pattern, which is a very popular design pattern. It&rsquo;s extremely useful in object-oriented programming. With Constructor Injection, dependencies are passed in via the constructor. The constructor then is being honest with the things that call it in that it is explicitly stating the things that it needs in order for it to be in a valid state and to be able to do the work that it expects to be able to do. The pros of this approach are that classes self-document what they need, it works well with or without a container, and I&rsquo;ll talk more about containers in a moment, and classes are always in a valid state once constructed. Some of the cons are that constructors can end up with a great many parameters if they have a lot of dependencies, which is a design smell in and of itself that needs to be addressed. Also, some features, for example, serialization, may require a default constructor. For example, a parameter list constructor, so even though you may have a constructor that explicitly specifies all of the things that your class depends on for reasons like the need to use serialization, you may also still have to expose a parameter list constructor that doesn&rsquo;t have those things set up. Also, some methods in the class may not require things that other methods require, so placing those dependencies into the constructor, effectively makes all of the methods require all of the dependencies. This is also a design smell because if you have methods in your class that don&rsquo;t require certain things, and other methods that do, it&rsquo;s likely telling you that your class lacks cohesion and it would be wise for you to refactor it into multiple classes that share dependencies and share, you know, common tasks. Another type of injection is Property Injection, which is also known as Setter Injection because you set the thing that you&rsquo;re injecting using the Set method on the property. Some of the pros are that the dependency can be changed at any time during the object&rsquo;s lifetime and thus this is very flexible, however, one of the cons is that objects are in an invalid state between construction and the setting of dependencies via setters, unless the constructor calls the setters, and it also can be less intuitive because there isn&rsquo;t any one place that you can go on that class, short of reading the documentation. That tells you exactly the properties that need to be set and perhaps the order of setting those properties in order for the class to ultimately be usable by the client calling code. And then the third method is through Parameter Injection. In this case, the dependencies are simply passed in as a parameter to the method. This is the most granular and it&rsquo;s very flexible. It does not require any changes to the rest of the class, however, some of the cons are that this breaks the method&rsquo;s signature, so if you have a method that&rsquo;s already in use by a great many classes in your application, some of which perhaps you cannot easily change, then breaking that method signature could be very expensive, whereas adding another constructor that allows you to pass in this dependency might be something that you can easily do without breaking any of the existing code that depends on that method. Similar to with Constructor Injection, this can result in having many parameters on your method, but again, this is a design smell in and of itself, and something that you should address in order to create a more cohesive design. You should consider using parameter injection primarily if you only have one method in a particular class that has a certain dependency, otherwise, it&rsquo;s better, in my opinion, to use Constructor Injection because this is able to make it very explicit to anyone using your code, what exactly it needs in order to function.</p>

<p>Refactoring</p>

<p>When we refactor our example class, the things that we&rsquo;re going to do in order to apply the dependency inversion principle are to extract the dependencies out into interfaces and then inject implementations of these interfaces into the Order. As a side thing, we&rsquo;ll also reduce Order&rsquo;s responsibilities by applying the Single Responsibility Principle, but we&rsquo;re going to just gloss over that as that&rsquo;s a separate module in and of itself. Let&rsquo;s look back at our solution and at our Order Object. The Order Object has a number of dependencies that we need to extract and we&rsquo;re going to do this by applying the Strategy Pattern and using something called Constructor Injection. So in order to do Constructor Injection, the first thing we need is a constructor, so I&rsquo;ll add that and we can take some of the things that are common throughout the entire class, that are currently parameters on Checkout and move these into our constructor&rsquo;s parameters as well. So for instance, we could say that our order requires a cart and then we can turn that into a field that we can use elsewhere. Likewise, we could say that we always have to have payment details, so we&rsquo;ll add those as well and make that a field too. And then the next thing we need to do is take some of our dependencies and convert those into interfaces that we can inject. So the first one that we see here is NotifyCustomer, and so we can simply take this exact signature and make that our interface. So we&rsquo;re going to say that we have a void NotifyCustomer and we&rsquo;ll come up here and we&rsquo;ll just create a new interface in the same class for now and we&rsquo;ll call it INotifyCustomer for now. And you see it takes a cart in order to do its work. If we look at this, we&rsquo;re going to see that the cart has the customer email and pretty much it looks like everything else it needs is here. Now the NotifyCustomer implementation might need to take in, you know, an ILogger or something at some point, but for now we can do what we need with just this simple interface, I think. So once we have this interface, let&rsquo;s go ahead and create a drive type for it and we&rsquo;ll just do this right here and we&rsquo;ll call this NotifyCustomerService and, of course, we want to implement the members and so we have a NotifyCustomer and we really just want to take this whole method out of here and place it into here and at that point we have this NotifyCustomerService that we could use. If we come back into our constructor, we can then pass in INotifyCustomer, and pass that in as well, and now it&rsquo;s just a matter of wiring up these fields so that they are using the fields instead. So if we come in here and change NotifyCustomer to be _notifyCustomer., now that&rsquo;s going to go ahead and call our NotifyCustomer method on our interface and we&rsquo;ve eliminated the dependency within Order on anything having to do with SMTP. Now we&rsquo;ll see in a moment how we can repeat this same process in order to pull out the dependency on the InventorySystem and the dependency on our ChargeCard. So let&rsquo;s look at our class dependencies as they began with our Order class and you can see that the Order class had strong dependencies on the PaymentDetails, the PaymentGateway, the InventorySystem, there&rsquo;s also not shown here a dependency on the System.Net classes that are doing SMTP stuff. Now I&rsquo;ve gone ahead and done all of this refactoring already inside of the loose coupling folder here and you can download this code and go through this yourself. The OnlineOrder is something that currently does the work of everything that you would expect for an online version of the order that needs to do notification, as well as credit card processing a inventory reservation. In the Single Responsibility Principle video, we looked at a couple of other alternatives to Order, for instance, if it was a point of sale order you might not need to do a NotificationService because the customer is standing there and they know that they made their purchase, but in this case we&rsquo;re talking about online orders. We identified these four fields that we wanted to pass in addition to the cart, which is being passed in on the base class of Order through its constructor. And finally, with each of these interfaces established, we also created default implementation, so the NotificationService looks like the one that I just showed you, and there&rsquo;s also a PaymentProcessor and a ReservationService that are simply cut and pasted out of what was there previously. So looking at OnlineOrder, we can see that the entire class is now only 36 lines of code and it&rsquo;s very easy to follow. You can also see that the new keyword does not exist anywhere in here. This class now takes in all of its dependencies through its constructor, making it very easy for us to test the class through the use of fake implementations. So let&rsquo;s look at what the tests would look like. If we look at our first test here where we want to send the total amount to the credit card processor, we want to verify that whatever the cart amount is is actually what we&rsquo;re going to charge the user&rsquo;s credit card. So for this, we&rsquo;re going to create fake implementations of each of our dependencies. We have a FakePaymentProcessor, FakeReservationService, FakeNotificationService, and we have a cart with $5.05 in it that&rsquo;s of payment type CreditCard. We create our order and check out. Once we check out, we want to check two things. We want to verify first of all that our PaymentProcessor was called at all and then we want to verify that our PaymentProcessor had the correct amount passed into it and we&rsquo;re going to compare that with the cart.TotalAmount. Now our PaymentProcessor interface does not support WasCalled or AmountPassed. If we go look at IPaymentProcessor, we&rsquo;ll see that the only method that it supports is ProcessCreditCard. So where are these coming from? Well the nice thing about our fake implementation is that we can do anything we want with it, so within our FakePaymentProcessor we don&rsquo;t actually process any credit cards, but we do have a couple of fields that we want to be able to access, one of them called WasCalled, one of them called AmountPassed, and using these we are able to verify that this method WasCalled and that the AmountPassed is the one that we expected. If we were interested in verifying the PaymentDetails, we could expose those here as well and then check for them in our test. Remember that the point of unit tests is not to verify that the full system works or to test whether or not the PaymentProcessor itself works, the point of the unit test on order.Checkout, which is the method that we&rsquo;re testing, is to verify that Checkout does what we expect it to do. What do we expect Checkout to do in this case? Well, we want it to process the credit card with the correct amount and we want it to call our ReservationService and we want it to call our _notificationService. We want to know that it does these things and perhaps that it does them under certain conditions and in a certain order, if necessary, and that&rsquo;s it. We don&rsquo;t want to have to test every little piece of the system just to test this one method, and that&rsquo;s what separating out the dependencies is allowing us to do is to isolate the order.Checkout method and be able to test just the content of this method without having to have actual implementations of all of its dependencies. If we look back at one of the original methods test that we had, we had a test here that said that it should not fail with no items, no credit card, but it should have notification. And if we run this, we see that we get this exact same behavior that we did before. So now let&rsquo;s look at the class dependencies on OnlineOrder and compare them with what we had with Order. We&rsquo;ve broken away from having dependencies on many of the concrete classes that Order had, and replace those with interfaces. So we now have dependencies on three interfaces, Reservation, Payment, and Notification, as well as dependencies on still PaymentDetails, the Cart, and the Order, but those were able to new-up without any kind of external infrastructure requirements like Web Services, Database, SMTP Servers, etc, and so this still allows us to test our OnlineOrder without having to use any of those extraneous bits of infrastructure. So just to review, the main change that we made is we went into OnlineOrder, we identified the dependencies that it had and created interfaces for those dependencies. We modeled those interfaces based on simply what this particular class needs so the client is the one that dictated what these interfaces should be, and then we moved the implementation details that previously existed in this class, into implementations of those interfaces. And this was pretty much just a straight cut and paste of the method that we had previously on order we moved into now a NotificationService, who currently has just the one responsibility of sending this message to a customer. This makes this particular class very easy to test and very easy to follow because it&rsquo;s doing only one thing and it cleans up our OnlineOrder class considerably as well, so that it&rsquo;s much easier to follow and simpler too. The nice thing about this is that OnlineOrder is now being very explicit about its dependencies. You know when you create an OnlineOrder that you must have a Cart, a PaymentDetails, a PaymentProcessor, a ReservationService, and a NotificationService. If you don&rsquo;t have those things, you simply cannot create an OnlineOrder. There&rsquo;s no default constructor for it, and so we are able to tell clients of the OnlineOrder class exactly what dependencies it needs in order to function.</p>

<p>Design Smells</p>

<p>Now let&rsquo;s take a look at some design smells related to the Dependency Inversion Principle. The first one is the simplest, it&rsquo;s simply the use of the new keyword. If you find in your code that you&rsquo;re using the new keyword and newing up actual instantiations of particular instances of classes, rather than interfaces, it&rsquo;s often a sign that you could apply the Dependency Inversion Principle. In this case, what we&rsquo;re showing you is this new InventorySystem. This is something that if it has external dependencies, maybe it&rsquo;s talking to a database, now the code around it has inherited that dependency, so the only way for you to keep this foreach loop from having to deal with whatever the dependencies that InventorySystem carries along with it, is to replace that with an abstraction and the simplest way to do so is to replace it with an interface that you use and then simply inject that interface using the Strategy Pattern and Constructor Injection. Similar to the use of the new keyword is the use of static methods or properties. This can be something as simple as a DateTime.Now that&rsquo;s crept into your code instead of having an actual DateTime passed in or an abstraction such as an iCalendar or an iDateTime interface that supports the Now method that you want to be able to pass in. Another very common scenario is the use of static methods to create sort of a façade layer for your DataAccess and so you&rsquo;ll see this frequently where you have something that offers a bunch of different methods like SaveCustomer or ValidateCustomer or things like that, which are static. And unfortunately, if you have a method that does a bunch of stuff and then ends with DataAccess.SaveCustomer, and that static method talks directly to ADO.NET and talks directly to the database, there is now no way to eliminate that dependency on the database. Just the same, if that static method is talking to a file system or any other dependency. So the best thing is to avoid static methods because of the fact that they cause these kinds of problems with inherited dependencies. The one place where you should use or could use static methods is when they don&rsquo;t actually touch anything other than the parameters that are passed into them. For example, if you had a static method that added two numbers together and it took in those numbers as parameters, there would be no problem with that because it&rsquo;s not going to cause any sort of a dependency problem, but if you have a static method that instantiates other classes and those classes might have dependencies of their own, now that&rsquo;s something that is going to likely cause you problems when it comes time to test.</p>

<p>Where to Instantiate</p>

<p>If we&rsquo;re not instantiating our objects, where do we insatiate them, you know, somewhere we have to do this. So typically what happens when you apply Dependency Injection is you get many small interfaces, which is good, because each one of them is very cohesive, they&rsquo;re loosely coupled to one another, they have the Single Responsibility Principle, they follow the Interface Segregation Principle, but at some point you have to actually create these objects. There&rsquo;s a couple of different choices for this. The first one is you can create a default constructor that then inherits from your constructor that actually takes in the interfaces and provides a default implementation of each of those interfaces. So in the example that we showed, we had an online order that took an INotificationService as one of the parameters in the constructor. We could create a default constructor that automatically passes in a new notification service, which is our default implementation of the INotificationService. Now any code that is calling this will continue to work just as it did before and we&rsquo;ll still be able to inject alternate implementations, for instance, in our tests when we wish to do so. This is sometimes poor man&rsquo;s dependency injection or poor man&rsquo;s IoC. IoC means Inversion of Control and we&rsquo;ll see that in just a moment. The other option is to manually instantiate everything in your application startup routine or main() method. In a web app this could be an application start in the global.asax and another option is to use an IoC container, which does the same thing typically in the main or startup method, but it has a bunch of features that it supports so that you can wire these things up in an intelligent fashion and go to one place and see how your object graph is going to be set up for your application.</p>

<p>IoC Containers</p>

<p>So, IoC containers or Inversion of Control Containers are responsible for object graph instantiation. They&rsquo;re initiated when the application begins and typically they either use code or configuration, such as an XML file to determine what is going to be set up to be used whenever an interface is called for. Managed interfaces and implementations to be used are registered with the container, so for instance, you might have in your container something that says you want to register INotificationService and say that anywhere I see an object that requires INotificationService, I want to use a new instance of NotificationService. Dependencies on these interfaces are then resolved either at application startup or at runtime. You can call, you know, an IoC Resolve method that will go and find whatever the instance is that&rsquo;s mapped to that interface at runtime or you can have a container that automatically is able to create the dependency graph for a given class by using its constructor. Typically the constructor that has the most parameters is the one that we&rsquo;ll use. So in the example with our OnlineOrder, we could have an IoC Container create one of those for us and it would automatically supply the types that were needed for the IPaymentProcessor, the IReservationService, and the INotificationService. Sometimes it&rsquo;s necessary to create a factory class that is able to create your class for you and then register the factory class and its dependencies with your IoC Container. IoC Containers are a fairly large topic in and of themselves. There are quite a few of them available, most of which are completely free. Some of those are listed here including Microsoft Unity, StructureMap, Ninject, Windsor, and Funq or Munq, just to name a few.</p>

<p>Summary</p>

<p>So to summarize, you should depend on abstractions rather than concrete types whenever possible. You want to avoid forcing your high-level modules to depend on low-level modules through direct instantiation or through static method or property calls. You want to declare your class dependencies explicitly in the their constructors wherever possible. You can inject dependencies through such constructors or alternatively through the property or through a parameter injection. Some of the fundamentals that are related to this topic include SRP, ISP, the Façade Pattern and Inversion of Control Containers, as well as the Strategy Pattern that we discussed. I recommend the Agile Principles, Patterns, and Practices book listed here, as well as Martin Fowler&rsquo;s article on dependency injection, which is at the URL shown right here. I need to provide credits for the one motivational picture I used for the Dependency Inversion Principle as shown here and with that, thank you very much. This has been part 1 of Principles of Object-Oriented Design Software Fundamentals, the Dependency Inversion Principle. We&rsquo;re going to have another second part to this that&rsquo;s going to show you how you can apply this principle at the application level and at the solution and project level in your Visual Studio projects. Thanks.</p>

<p>The Dependency Inversion Principle, Part 2
Introduction</p>

<p>Hi, this is Steve Smith, and this is going to be part 2 of the Dependency Inversion Principle, one of the principles of object-oriented design and a software fundamental, part of the solid principles of object-oriented programming. In this module, we&rsquo;re going to talk about Project Dependencies in our Microsoft Visual Studio applications. We&rsquo;ll look at the problem that occurs when we have dependencies flowing in such a way that the infrastructure and low-level concerns of our application are depended upon by all the other projects in our app. We&rsquo;ll go through an example that shows this particular type of architecture, which is very common, and the problems that arise when one uses it, and then we&rsquo;ll refactor this design, applying the dependency inversion principle at the solution level so that we can improve the design and maintainability of our application. Finally, we&rsquo;ll wrap up with some related fundamentals.</p>

<p>Definition</p>

<p>In a typical layered or tiered application design, there are separate logical and sometimes physical layers. For instance, it&rsquo;s very common to have a User Interface Layer, a Business Logic Layer, and a Data Access Layer. Oftentimes, these will each correspond to separate projects in Visual Studio. The nice thing about this approach to design is that it supports encapsulation and abstraction. It also works at the application level that is appropriate to each layer. Each level should only know about one level deep if possible, because this allows for the individual layers to be swapped out at a later date without affecting the layers above it. This provides a good unit of reuse, but the lowest levels are generally the most reusable because there are many more layers above them than, for instance, a User Interface Layer, which is typically not reusable, and usually is at the top of the dependency hierarchy. This diagram shows an example of the traditional or naïve layered architecture approach with the flow of dependencies going from top to bottom. As you can see, the User Interface is sitting at the top here and it&rsquo;s depending on a Business Logic Layer that makes up the main central area of the app, and most of the Business Logic Layer classes are going to end up calling Data Access Layer or Common Assembly classes in the Data Access Layer or some kind of service layer is going to talk to the Database or talk to Services. If the dependency flows in this direction and since we know dependency is transitive, this means that the User Interface is always dependent on the Business Layer and the Business Layer is always dependent on this Data Access Layer, which in turn depends on the existence of a Database and Services in order for it to function. What this means is that your application is very difficult to test or change or work with in isolation from a Database or these Services because of this hard dependency that&rsquo;s flowing from the Business Layer through the Data Access Layer. This means also that we are not depending on an abstraction, rather we are depending on an explicit instance of the Data Access Layer which we&rsquo;re going to be working with. We can invert this architecture so that the thing that sits at the bottom of our dependency structure is, instead, the Object Model, the Core, the Domain Objects, as well as perhaps our Business Logic, and Services. These can be packaged together as a single assembly or separately if you prefer. It&rsquo;s also important to note that any of the dependencies that these have are represented by interfaces at this layer. Next, the other areas of the application such as Data Access, User Interface, Tests, I/O Operations, and Web Services or WCF, would all be on top of this and would depend on these services and objects. Infrastructure concerns outside of our application, such as the Database or Web Services themselves, would reside off to the side where only the Data Access Module would depend on it or the WCF or Web Service Module, but note that our Business Logic and Core Domain Objects would not have this dependency, and as a result they could be tested without having to have these in play.</p>

<p>What are Dependencies</p>

<p>Let&rsquo;s look at a demo of how we can build an application that follows the traditional hierarchy and what effect this has on our ability to work with that application. One of the new features of Visual Studio 2010 is the ability to use the Architecture tab to generate a dependency graph by assembly. If we do this for this project, we will see something like what&rsquo;s shown here where we have our NTier.Web and WebService assemblies at the top of our dependency hierarchy, and these are correspondingly referencing our Business Logic Layer and the Business Logic Layer is currently referencing the Data Access Layer. The Data Access Layer, as well as pretty much every other assembly is making use of a set of common functions that&rsquo;s in a common assembly and then these are all referencing externals, such as ADO.NET or WebService classes. This is also where you would find things like the Database or external things like the file system, etc. Looking at this design, it&rsquo;s very clear that our Business Layer depends on the Data Access Layer, which in turn depends on externals. This can make it very difficult to change the Business Layer or to test it in an isolated fashion. For instance, if we were to go and create a Test Class like this one, we could say that we wanted to have a class that tests the Security Class of the Business Layer and say that Security&rsquo;s login method should return a user Id for a valid user. We construct our test with a validUserId, email, and password, and of course, we would like to be able to inject these into the system somehow so that we could do this test with our data here that we are passing in. Unfortunately, this is implemented as a static method, making it very difficult for us to do any sort of dependency injection. And when we write this test, if we stop ignoring it and run our test, we&rsquo;ll see that because of this dependency on Data Layer, our test throws an exception and that exception is that it can&rsquo;t find the Connection string in the web.config. Of course, I don&rsquo;t want there to be a connection string in my Unit Test web.config, because I don&rsquo;t want Unit Test to be talking to external resources. I only want to be testing the Business Layer, I don&rsquo;t want to be testing the Data Access Layer or the Database with this particular test suite. Now I actually put together this demo many years ago when .NET 1.0 was out, in order to show how NTier applications should be structured. This is before I was familiar with the Dependency Inversion Principle. And one of the things that I struggled with as I put together this demo was how I could easily swap out one Data Access Layer for another. Part of the intent of this demo was to be able to show how easy it would be to take, for instance, our Security Layer and change it so that the Data Access Layer that it&rsquo;s using could be swapped from one that uses SQL Server through the SqlParameters and SqlConnections for a different Data Access Layer, which is here, called Data Access Layer 2. And Data Access Layer 2 uses an XML file. So the idea was that one could switch from one to the other and in the course of my demo, the way that I would do that, because I didn&rsquo;t know any better, was that I would go in here and I would have to change DAL to DAL2 and I would have to change my references to make sure I had the reference to Data Access Layer 2, and everywhere that I called Data Access Layer 1, I would have to change those references. Of course, if I can just delete the reference and lean on the compiler a bit, it&rsquo;ll show me all those places and I can come in here and change them appropriately. In this particular demo, I only have three methods that call Data Access Layer, so I only have three places where I need to make this change, but the fact that I have to go and touch every line of code, is definitely a violation of the Open Closed principle and it was certainly something that bothered me at the time, but I just didn&rsquo;t know of a proper way to change that and avoid that situation. Many applications that I still see have the same problem because they rely on static methods and/or because they use this same type of dependency hierarchy that puts the Data Access Layer below the Business Layer with a direct class-level reference and assembly-level reference that passes from the Business logic to the Data Access Logic. This results in more fragile applications that are more difficult to change as you evolve them and as you wish to adjust their behavior.</p>

<p>Traditional Programming</p>

<p>Let&rsquo;s analyze some of the problems with the existing application structure. The biggest one is that dependencies tend to flow toward infrastructure concerns such as the database and XML files going through Data Access Layers that are tightly coupled to these structures. The Core, Business Layer, and Domain classes, such as we have them in this example, all depend on these implementation details. And if these implementation details change, it requires us to go in and change our Business Layer, at the very least recompiling it, but in this case actually going and touching lots of individual method calls in order to fix their references so that they continue to function. The result of this is that we have tight coupling between the Business Layer and, by extension, the Data Access Layer and the XML file and the infrastructure components that we are using in our application. There&rsquo;s no way to change these implementation details without a recompile resulting in an Open Closed Principle violation, and making this very difficult to test in any kind of an isolated fashion. Dependency Injection shows that dependency is transitive. If the UI depends on the Business Logic Layer, which in turn depends on the Data Access Layer, which in turn depends on the Database, then everything depends on the Database. We want to, instead, depend on abstractions where we know that there are likely to be changes in our application. We want to package up these abstractions, these interfaces, with the client that&rsquo;s using them, in this case the Business Logic Layer, in keeping with the Interface Segregation Principle. Finally, we want to structure our solutions and projects so that the Core or Business Logic Layer is at the center or at the bottom of our dependency hierarchy with the fewest dependencies and with no dependencies on external infrastructure.</p>

<p>Class Dependencies</p>

<p>Now let&rsquo;s see a demo of how we can refactor our naïve interior design into something that follows the Dependency Inversion Principle, and gain some of the benefits of a more flexible architecture. We&rsquo;re going to refactor this NTier application in order to make it work in such a way that the Business Layer is the center of all the dependencies rather than depending upon the Data Access Layer. I&rsquo;ve changed this application back to where it was when we started so that it&rsquo;s now using the NTier Data Access Layer assembly, which is depending on the SQL Database. If we run our test here, we can see that it fails and it fails with the exception saying that it cannot find our Connection string. The reason for that is because this Security.Login method is defined over here and it&rsquo;s calling Data Access Layer Security.Login through a static method call, and if we look at the Data Access Layer Security.Login we can see that it&rsquo;s actually generating some sql, opening up a connection, and ultimately executing that using ADO.NET. When we&rsquo;re done, we&rsquo;ll be able to use this test with a little bit of additional code in order to pass in the expected record that we want to find, run our login, and verify that it did, in fact, return the correct result. We&rsquo;ll then be able to add additional tests if we would like to make it so that our Login and Security classes function the way we expect them to. Let&rsquo;s get started. The first thing we need to do is go into the Security.Login method and make it so that it&rsquo;s no longer static. Static methods are very difficult to test and very difficult to mock out in your test, so eliminating that is the first step in improving our design. Once we do this, we need to build and fix anything that was expecting a static method and change it by simply newing up the class that we need and applying a couple of parentheses. If we do this in each location where it is being used, we quickly get back to a state where everything builds. There, now we have a Security Class instance that we can use. The next step is we want to generate an interface that shows the things that this depends upon. I&rsquo;m going to use what&rsquo;s called the Repository Pattern in the definition of my interface to make this work. Now if we look at what the security code is actually doing, it&rsquo;s selecting a user based on their email and password and returning back that user record. So let&rsquo;s look at how we would identify an interface for this. In the Security Class at the Business Logic Layer level, we would say that this is depending on some kind of a Data Access repository that&rsquo;s able to get a user by email and password. So, I&rsquo;m going to say that we need a new interface. We&rsquo;ll call this public interface UserRepository, and we&rsquo;ll say that it has a method called GetByEmailPassword. That takes in a string email and a string password, and it returns back an int, which is the User ID. Now I can also come in here and say that I need a new constructor for Security and in this constructor I am expecting, we&rsquo;ll make this an IUserRepository, I am expecting an IUserRepository called userRepository and I&rsquo;m going to introduce and initialize a field called _userRepository. And now I can take that instance and use its method here, so I really want to say _userRepository.GetByEmailPassword and at this point I&rsquo;m back to a state where I can rebuild, except that I don&rsquo;t have a default constructor, so the next thing I need to do is create a default constructor and I&rsquo;m going to have it use the other constructor&rsquo;s interface and pass in a default implementation, which in this case we&rsquo;re going to say is a SqlUserRepository. Now I don&rsquo;t actually have one of these yet, so we&rsquo;re going to generate one, and this all looks good, and we&rsquo;re going to implement the members, and now we should be able to build. Alright, maybe not, what did we miss? Oh yes, we need some curly braces and now we can build. Alright, so at this point we have an interface, we have a couple of constructors now, and we&rsquo;ve created a SqlUserRepository that doesn&rsquo;t actually do anything yet, but it will. And the SqlUserRepository right now is living inside of this same file, but we&rsquo;re going to break that up in a moment. So the next step is to move around some files. We need this interface to live in its own file so we&rsquo;re going to say move it to another file and we further want the actual SqlUserRepository to live in its own file, and in fact, we&rsquo;re going to see that we want it to live in an entirely different location, different assembly, but for now we&rsquo;re going to create a new folder for our interfaces and we&rsquo;ll move our IUserRepository into this folder, and then I also want to create another location to put this SqlUserRepository. So I&rsquo;m just going to create a new Data Access Project, so we&rsquo;re going to have a new project here. We&rsquo;ll call it a C#, Class Library of NTier.Data.Sql. NTier.Data.Sql does not need to have any classes in it at the moment, but we do want it to have our SqlUserRepository, which we can now delete from here and this SqlUserRepository is going to have to have a reference back to that interface, so we&rsquo;ll add a project reference NTierBLL and we&rsquo;ll ensure that this repository here has the right namespace. And that looks good. Now the challenge here is that we no longer are able to have our default constructor here know about that SqlUserRepository, so we&rsquo;re going to just comment that out for now, but we&rsquo;ll take that code and we&rsquo;ll have to put it where things are calling this. So in these three places where we call our constructor, really only two of them, we&rsquo;re going to need to insert that code, so we&rsquo;re going to insert it here and in addition to this we&rsquo;re going to have to give them a reference now to this new location. So NTierWeb is going to have to know about this new project reference with NTierData.Sql. And NTierWebService is going to also have to have a new reference to that same one and that&rsquo;s just so that we can build. Now if we look back to our error list, I have one more I need to fix, I believe. I&rsquo;m pretty sure there were two. So here I need to add that and that&rsquo;s happy. And then here I need that namespace so it&rsquo;s happy. Now in my test, I don&rsquo;t want to add any dependency on the Sql, because that&rsquo;s not what I want, so I want to have instead, something like a new FakeUserRepository. And for this we&rsquo;re going to go ahead and new this up and a FakeUserRepository will need to implement that method as well and we can tell a FakeUserRepository do something like return validUserId, where validUserId is a public int field on that class. We can further say that we have a public string ValidEmail, public string ValidPassword, and then we can simply say, if email = ValidEmail and password = ValidPassword, return validUserId, else, return 0. And now we can come up here and we can change this so that we say var fakeRepository = new FakeRepository, fakeRepository.ValidUserId = validUserId, fakeRepository.ValidEmail = validEmail, and fakerepository.ValidPassword = validPassword. Now the last thing we need to do is use our fakeRepository instead of this new FakeUserRepository. And at this point we should be able to run our test and we should have a passing test. If we look back at our Business Logic Layer and specifically at the method that we changed, you can see that we have in this case a single interface that we needed to create and we eliminated the new Keyword from anywhere inside this class. We delegated the responsibility for determining which particular instance of a UserRepository we would be using to the caller, which is inverting that dependency, that&rsquo;s applying the Dependency Inversion Principle. So this is poor man&rsquo;s IoC we weren&rsquo;t able to use in this case because we moved the implementation into its own assembly that we don&rsquo;t want to be referencing and pushed that responsibility for newing up that SqlUserRepository to our calling code. What this allowed us to do is to have our User Interface Layer, which is this Login.aspx, is able to say that it wants to use a SQL Database here and, in fact, we could use an IoC container to make this much more flexible, but for our purposes here you can see that we can just hard code it into the user interface and this still allows our test to pass in a different implementation of the IUserRepository. In this case, we&rsquo;ve created a FakeUserRepository that lets us set the valid user and password information and then test for it. Now there&rsquo;s nothing to say that I had to do this in this particular way with three public fields. Instead, I could have had an array list of users that I wanted to specify, and that would&rsquo;ve worked just as well. One last note is in addition to the, sort of, services, like Security here, that doesn&rsquo;t have any kind of state, but is simply a collection of methods that apply, there are also going to be domain objects. In this case, the only domain object that we really have in our application is this UserDetails class that we haven&rsquo;t really done anything with thus far, and right now this lives in the Common assembly because it&rsquo;s used by multiple layers in this application. It would be perfectly acceptable to take this and move this class into our Core as a domain object, call it User most likely, and any kind of logic that was specific to the user would also live in this class, and then it would be depended upon by any of the other areas in our application. So for instance, if we implemented our user&rsquo;s services, which have things like AddUser and GetUser, these would turn into a repository. The repository would know about how to create users or fetch users, and when returning a user, it would return back that Core domain user class that would be inside of that Business Layer assembly rather than in a separate assembly. After we complete our refactoring of the NTier Business Layer to make it use separate interfaces for its dependencies, you can see that the dependency graph now looks something like this with the User Interface, Web, and Web Service Layers depending on the infrastructure or SQL Layer directly and the Business Logic Layer, but notice that the Business Logic Layer no longer depends on its infrastructure. Unit tests are able to depend on it and test it in isolation. This dependency from the UI to the Data Layer, would also easily be broken if we introduced another assembly that was specifically for dependency resolution. And it&rsquo;s a common practice to create such an assembly where one&rsquo;s IoC container work resides. So to summarize, the most important thing that I want you to take away from this module is that you should not depend on infrastructure assemblies from your Core Business Layer in your Visual Studio solution. You can apply the Dependency Inversion Principle to reverse these dependencies by taking new interfaces, adding them to your Business Layer, and then having the implementations of those interfaces be in separate projects that depend on the Core Business Layer. Some of the fundamentals that are related to what we&rsquo;ve talked about include the Open Closed Principle, the Interface Segregation Principle, and the Strategy Design Pattern. And for additional reading I suggest the Agile Principles, Patterns, and Practices book by Robert C. Martin and Micah Martin, as well as this Martin Fowler article on injection in general. This has been Principles of Object-Oriented Design, the Dependency Inversion Principle Part 2 for Pluralsight On-Demand. Thanks for watching and I hope that you&rsquo;ll find additional videos useful on the Pluralsight On-Demand library.</p>

<p>The Don&rsquo;t Repeat Yourself Principle, Part 1
Introduction</p>

<p>Hi, this is Steve Smith. Welcome to this Pluralsight on-demand module on The Don&rsquo;t Repeat Yourself Principle. The Don&rsquo;t Repeat Yourself Principle or DRY is one of the fundamentals of object-oriented design and software engineering, and personally I think that this is one of the most important principles for every developer to learn. In this module, we&rsquo;ll start out by defining the Don&rsquo;t Repeat Yourself Principle and then we&rsquo;ll go through a demo showing how misuse of this principle results in Spaghetti code that&rsquo;s very difficult to maintain. After a little bit of analysis, we&rsquo;ll go through a series of demos showing how we can refactor such code to DRY it up and make it much easier to maintain and continue to use. We&rsquo;ll briefly look at some Code Generation options before moving on to show what repetition in your process can do and how it adds to the waste of your process. And then we&rsquo;ll show a quick demo on how we can automate our process to apply DRY as well. Finally, we&rsquo;ll wrap up with a summary and related fundamentals.</p>

<p>Definition</p>

<p>If you&rsquo;ve been following this series, you probably know that I like these motivational posters. This one I produced myself, and as you can see it shows the punishment for repeating yourself should be something like repeating yourself at the chalkboard. I do believe that repetition is the root of all software evil and that most of the major problems and bugs that crop up in software or that make it more difficult to maintain could be avoided through the proper use of the Don&rsquo;t Repeat Yourself Principle. This principle was first coined in the Pragmatic Programmer book and stated as, &ldquo;every piece of knowledge must have a single unambiguous representation in the system.&rdquo; Note that these pieces of knowledge are not just values, but they might also be processes or algorithms or approaches to problems and abstractions in your application. In the book 97 Things Every Programmer Should Know, I noted that &ldquo;Repetition in logic calls for abstraction. Repetition in process calls for automation.&rdquo; Variations of the DRY Principle include Once and Only Once, as well as Duplication is Evil.</p>

<p>Demo App and Analysis</p>

<p>Now let&rsquo;s take a look at a demo of a simple Data Warehouse example that I wrote which violates DRY all over the place, and then we&rsquo;ll see how we can clean this up by applying this principle. In this sample application we have a Data Warehouse loading program, which we&rsquo;re calling Extract, Transform, Load, or ETL. ETL is a common pattern in Data Warehousing and if you do a search for that pattern you&rsquo;ll find a number of commercial products that focus on Data Warehousing solutions. In this case, the basic steps that we want to apply is to extract some data from our Data Source, perform some kind of aggregation or transformation on that data, and then load this into our summary tables or our Data Warehouse, and then finally finishing up the program. In this example, I&rsquo;m going to be talking to the Northwind Database. As you can see here in my hard-coded connectionString, my Extract method is going to open up a SqlConnection, perform a query against Invoices, and put that data into an invoiceTable. It&rsquo;s going to do some logging and output what it&rsquo;s doing as it goes. Then it&rsquo;s going to open up another connection, also to Northwind, and it&rsquo;s going to query the employees and store this information in an employeeTable, and as it goes it&rsquo;ll write out the results. In our Transform step we&rsquo;re going to first take that list of shippers that we loaded in the Load section in the extraction method and we&rsquo;re going to through each one of these shippers, get a count of them, and then basically take out the sum of the freight that that shipper received over the period of time that we loaded. When we&rsquo;re done, we&rsquo;ll also calculate the total freight from that period of time as well. Next we&rsquo;ll go and analyze the employees. We&rsquo;ll pull out whether or not that employee is a manager based on how many employees report to that employee, and then we&rsquo;ll calculate the bonus for each employee based on that calculation of whether or not they&rsquo;re a manager. Finally, now that we have all of our data we&rsquo;re prepared to load it back into our Data Warehouse, so we&rsquo;ll have to open up another connection. In this case we&rsquo;re talking back to the same Data Source, but in a real system it would likely be a different one. We&rsquo;ll clean up any data that was already there and then we&rsquo;ll insert our records with our new summary data. We&rsquo;ll do that same thing for the employees, cleaning up what was there and then inserting new records for their bonuses. You can see that this set of code is about 200 lines of code and the only classes in it are our Main Program class here, as well as a class for FreightByShipper, which simply shows the shipper name and the freight that they charged during that period. And then for employees, these employees simply have the name, whether or not they&rsquo;re a manager, and their bonus. If we run this code, we&rsquo;ll see that it all executes, it finishes up in not too much time, and you can see that it logged all of the things that we expected it to out to the console. Now let&rsquo;s see what we can find as violations of the Don&rsquo;t Repeat Yourself Principle in this code and what we can do to correct it. A very quick analysis of the code shows a number of problems with the Don&rsquo;t Repeat Yourself Principle. These can be broken out into the following bullet points. The first one is the use of many Magic Strings or Values throughout the code followed by duplicate logic showing up in many different locations. There is repeated if-then logic in some branches of the code, as well as the use of conditionals instead of polymorphism. There are some repeated execution patterns where the same couple of lines or several lines of code are executed with some slight variation over and over again. And there&rsquo;s a lot of duplicate, most likely copy-pasted code that we can probably find with an automated tool and clean up. We have only manual tests in the code at the moment and there are a lot of static methods, which we&rsquo;ll see can also prove to be problematic.</p>

<p>Refactor Magic Strings</p>

<p>There are quite a few examples of Magic Strings or Values in this code. The first one is the use of the ConnectionString being hard-coded throughout the code. Obviously this is not a good practice and something that we should move to a more secure location perhaps, and in any event, a single location that defines our ConnectionStrings for this application. Formatting Strings are also specified in many different locations, as well as these blocks of foreach logic to dump things to the console. If at some point we want to change how this data is formatted or if we wanted to change where it&rsquo;s being displayed, these would need to be updated in many different locations. Another section is using magic numbers, in this case the number 1 is specified in multiple locations here without any indicator of why it is significant. And again, there&rsquo;s the use of formatting strings here that are repeated in multiple locations. Let&rsquo;s look at how we can apply DRY to remove magic strings. We&rsquo;re going to look at applying the DRY Principle to remove some magic strings and values from our application. We&rsquo;ve analyzed it and found that we have a number of cases where we&rsquo;re setting this ConnectionString over and over in our code. We&rsquo;d like to move that to a single unambiguous location that defines the ConnectionString for the application. One option would be to move this to ConnectionStrings. We would do this by adding ConfigurationManager, which we&rsquo;ll have to add a reference to. So we&rsquo;ll add a reference to .NET, System.Configuration, and ConfigurationManager has a ConnectionString section where we could specify a name for this. We&rsquo;ll call it the Main Connection string .ConnectionString Now in order for this to work, we&rsquo;ll also need to add a new App.config value, and within our app.config we&rsquo;ll add a ConnectionString section with a new connectionString. We&rsquo;ll paste in the actual ConnectionString we&rsquo;re using and we&rsquo;ll also give it a name. By doing that, we can delete this one here and run our code, since we have no actual tests, and if it still seems to work, then we can be confident that that&rsquo;s working. However, if we go through and add this logic that specifies the use of ConfigurationManager, everywhere that we&rsquo;re using a ConnectionString in this code, we&rsquo;ll simply have changed one kind of duplication in exchange for another, because now if we later decide to change what the name of that value is for Main, or if we decide to use a different method of storing the ConnectionString or passing it into this method, we&rsquo;re going to have to change this in many different locations. So we&rsquo;ve improved where the value of the ConnectionString is stored, that&rsquo;s no longer repeated, it&rsquo;s only in one place here, but we haven&rsquo;t gotten rid of the repetition in how we get to that ConnectionString. We can do that by simply pulling that method up to a class-level variable. So we&rsquo;ll say string connectionString equals this value and we&rsquo;ll replace this with this and now there&rsquo;s a refactoring that we can use here where we can introduce this as a field called _connectionString and now we&rsquo;re using that _connectionString field, and if we move this initialization code up here to the beginning of our Main method, we can then use _connectionString throughout for all of our ConnectionStrings. (Typing) I think that&rsquo;s all of them, so now if we run the code again it should still work, and it does. And at this point we can see that we&rsquo;ve pulled out a fair bit of repetition into this one line that now aggregates all of that information in one place. Another thing that we saw when we analyzed our code was the frequent use of two things, one being this Console.WriteLine, another being the use of this format string, and in fact, this entire foreach loop is somewhat repetitive. As you can see, we&rsquo;re doing it both for our invoice table here, as well as down here for our employee table. We can apply an Extract method refactoring in order to pull this data out and give us a common way to write it out. If we want to pull out this logic for writing out a number of rows inside of a DataTable, rather than working at the Row level, we can simply create a new method that takes in the table and dumps out the results using this kind of format. We&rsquo;ll start off by creating this new method, and at this point, we simply want to take the logic we had before, for instance, this foreach loop, and convert it so that it&rsquo;s using our table. However, we want it to work over the number of columns that the table has, so we&rsquo;ll do something like this. We&rsquo;ve added in a bit of logic here that will determine what the total number of columns is and then loop through those columns, adding in the row with that column index and then a hyphen between each one and finally a WriteLine at the end if we don&rsquo;t have any more columns. This will dump out all of the columns in the table. If we want to actually limit this, because for instance, our actual usage up here is perhaps only showing a certain number of columns, 3, even though it&rsquo;s selecting all the columns in the table, we can pass in a column count, so int columnsToDisplay, let&rsquo;s say, and we&rsquo;ll use that here in place of columnCount. So instead of just table.Columns.Count, we&rsquo;ll say it&rsquo;s going to be that, but if columnsToDisplay is greater than 0 and less than columnCount, we&rsquo;ll say columnCount = columnsToDisplay. And then we can delete this old Console.WriteLine that we had before and use our OutputTable method now in place of these locations here. So we&rsquo;ll say OutputTable and we&rsquo;ll pass in invoiceTable, which we want to show 3 columns, and we can have our columnsToDisplay have a default value if we want to, so we&rsquo;ll make that 0, = 0. And that&rsquo;ll let us pass in nothing for it when we use it down here for our employeeTable. Now if we run this, it hopefully will still work, and it does. And if we scroll all the way to the top, well we&rsquo;ll have to turn off some of our logging here to make this easier. Let&rsquo;s just do our load and run to show. These are all the invoices being output, and at the end these are our customers or our employees, rather. So you can see this is still working the way it did before. We have our hyphen-separated columns. The next magic value that we had in our application appeared in our Transform section where we&rsquo;re doing these if statement checks and we&rsquo;re checking whether the count was greater than 0 and then we&rsquo;re grabbing the first item, and if the count was greater than 1, then we&rsquo;re going to grab the second item, which has index 1. And this number 1 here is the same as this number 1 here and this number 1 over here, and so we could do a simple change to say something, obviously we could fix this in several ways, but the simplest change here to remove that magic number is to have something like int index, which we&rsquo;ll set to 1 and then replace those 1&rsquo;s with our index value. Now if we need to change that, even if it&rsquo;s a copy-paste change, we won&rsquo;t forget one of those 1&rsquo;s when we do it down here and we have these 2&rsquo;s instead. We&rsquo;ll see how we can clean up those if statements in a separate refactoring. And the other thing that we have here is a FormatString. This is for formatting numeric values, decimals in this case. If we want to pull that out, it would simply be a matter of creating a new value. We could create it here, for instance, and then anywhere we want to display that decimal FormatString or we want to use it rather, we would just replace it here, and here, and here with that FormatString. Alternately, this method of doing this WriteLine could be extracted out into its own method. In fact, this entire chunk of if logic could be extracted into its own method or its own separate loop that does this work, but again, that&rsquo;s a separate exercise. So at the moment, we&rsquo;ve pulled out a number of magic strings, we&rsquo;ve eliminated the connectionString duplication, we&rsquo;ve shown how we can output an entire table, rather than having repeated loops for displaying rows, we could apply that same logic in other places in our code where we&rsquo;re doing looping and doing output to the console, and lastly we&rsquo;ve looked at some display FormatStrings and shown how we can easily replace those with a variable in our application.</p>

<p>Refactor Duplicate Logic</p>

<p>We see that our application has duplicate logic in multiple places. For instance, there is this logic here for specifying how to output data to the console, as well as separate locations where we&rsquo;re opening up a connection. Let&rsquo;s look at how we can apply some refactorings to clean this code up as well. We&rsquo;ll start with a fresh copy of our original solution. Here&rsquo;s our code, and we can see that we have our ConnectionStrings duplicated as we did before, and we have logic here for dumping things out to the console, which we would like to replace with a single new method. We also have a number of different places where we&rsquo;re doing this connection logic to open up a connection and get back a DataTable. We&rsquo;re doing that twice here, as well as down here in the Fill section we&rsquo;re opening up a connection, executing a query, and in this case we&rsquo;re doing an ExecuteNonQuery call and we&rsquo;re doing that a couple of times, in fact, we&rsquo;re doing it four times just in this one method. Now we can extract out this code ourselves or there are a number of well-proven tools that will do this for us. Let&rsquo;s look at an example tool. The simplest tool would be to add a Northwind DataContext using LINQ to SQL. So we&rsquo;re going to go add a new item, we&rsquo;re going to use a LINQ to SQL Class, we&rsquo;ll call it Northwind, we&rsquo;ll go over to our Server Explorer and we&rsquo;ll drag on the tables that we&rsquo;re interested in, and let&rsquo;s see, we also wanted employees and invoices. We&rsquo;ll set up the property for this. We&rsquo;ll say that our Entity Namespace should be entities and everything else looks good. Now if we look at our code, the first thing we&rsquo;re going to do is delete a FreightSummary. So instead of using a connection, we&rsquo;re going to say using(var db = new NorthwindDataContext. And because we don&rsquo;t have our configuration set up for our ConnectionString, we&rsquo;ll just hard-code it for now. And within this DataContext we want to first grab the one that we want to delete, so our shipperToDelete is going to be from shippers in db.FreightSummaries where shippers.Name = the individual shipper in our loop that we&rsquo;re on, .name, and the date, the RunDate = DateTime.Today. We&rsquo;re going to select the whole record and we just want the first one, so we&rsquo;ll grab that and for our first we&rsquo;ll do that here. We&rsquo;ll say db.FreightSummaries.DeleteOnSubmit(shipperToDelete.First And we&rsquo;ll go ahead and submit this now. That takes care of this big chunk of code here. Next, we want to insert a new record with the RunDate and the values from our shipper that we&rsquo;re on. So for that, we&rsquo;ll do basically the same thing. We&rsquo;ll say our shipperToInsert is a new FreightSummary. Now this is our entity FreightSummary that LINQ to SQL just created for us. And we will say that its freight is our shipper, freight, and its name is our shipper.name, and its RunDate is still DateTime.Today. And then we want to just do an insert on this, so it&rsquo;s db.FreightSummaries.Insert (shipperToInsert), db.SubmitChanges And if we apply this now to this logic here, this is our using statement, you can see it becomes much smaller at this point and we should be able to run our code and it should work, and it still does. We would do the exact same thing here, but for the sake of time we won&rsquo;t show that to you. And so that&rsquo;s an example of how we can use LINQ to SQL in order to eliminate a lot of repeated ADO.NET code. We&rsquo;re still going to see some repetition in this pattern where we&rsquo;re looping through each one of these and doing some kind of a Delete followed by some kind of an Insert and we could certainly eliminate that duplication as well using a different refactoring technique. The other duplicate logic that we saw was this output logic up here where we&rsquo;re looping and dumping out this stuff. We actually cleaned that up in our magic string section, but just for the sake of completeness, we&rsquo;ll show that technique here as well. If we go and we add a method to Output the Table here, then we can refactor these calls so that they simply say, OutputTable with our table name, and the same thing here for our invoices, taking care to change this. And we only want to show three columns for the invoice one. And if we run this you can see that we&rsquo;re still getting here are our employees and here are invoices being output as expected. So we&rsquo;ve done that refactoring. Let&rsquo;s look at the next one.</p>

<p>Refactor Repeat if-then</p>

<p>Another symptom of violations of the Don&rsquo;t Repeat Yourself Principle that we see in our code is this Repeated if-then Logic. In this case, too, we can see that we&rsquo;re simply checking whether or not the count is a certain value in order to ensure that we are able to write out the value to our table. Let&rsquo;s look at how we can clean this up. So this logic occurs within our Transform method where the first thing that we&rsquo;re doing is grabbing this invoiceTable and loading it with the values that we want into our freightShipperList. So for each row, we&rsquo;re adding a value and then we&rsquo;re checking to see if our list has a certain count. We want to go and calculate the freight for that particular entry and specify it here. And then if it&rsquo;s another count of greater than 1 or a count greater than 2, we&rsquo;re going to do this, and you can imagine that if we had dozens and dozens of shippers we would end up with many, many instances of this particular if-then block. This can be replaced quite easily with a loop. In fact, it could all be done inside the loop that we already have up here, where instead of specifying what we&rsquo;re doing in a separate if block, we can just extract out a method for it and say here that the freightByShipper, well first we&rsquo;ll pull out the actual entity that we want, so we&rsquo;ll say, var myShipper = and we&rsquo;ll grab this new value here that we want and I&rsquo;m sure there&rsquo;s a refactoring that&rsquo;ll do that for me. And we&rsquo;ll put in myShipper there, and then the only other thing we need to do is say that myShipper.Freight = CalculateFreightForShipper, and we&rsquo;ll pass in, what do we need, the name, so myShipper.ShipperName, and as well the invoiceTable, which we have a reference to, so we&rsquo;ll do this, we&rsquo;ll generate this method. And at this point we simply copy out the guts of our if-then logic here, paste that into our new method here, and say that we&rsquo;re going to return this calculation here. And we really only need the ShipperName at this location here, so that lets us do our computation and eliminates the need for this block. Now we want to write it out, so we want the ShipperName, as well as the result, (Typing) and then we can just return the result. That allows us to eliminate all of these if checks by doing all of that work inside of this one loop, which now is one line of code. So we&rsquo;ve reduced our total lines of code significantly. We&rsquo;re taking advantage of a loop that we already had. If we didn&rsquo;t have this loop, we could have simply created our own loop that looped through each of the freightByShipperList entries to do this work as well. But it&rsquo;s common refactoring to be able to take a number of if statements and replace them with some kind of a loop. And so now we should be able to run this application and everything still works as it did before.</p>

<p>Refactor Conditional w/Polymorphism</p>

<p>Another violation that we have to the Don&rsquo;t Repeat Yourself Principle is caused by this Conditional Instead of Polymorphism. Here we see an example of the Flags Over Objects anti-pattern, where it&rsquo;s violating the Tell, Don&rsquo;t Ask principle, which is also known as the Dependency Inversion Principle. Because we&rsquo;re asking this particular object whether or not it&rsquo;s a manager and then using that to compute the bonus ourselves within this external calling code and setting it in a field within the employee object. Let&rsquo;s look at how we can refactor this to apply the DRY principle and make it use polymorphism instead of this if-then logic that will eventually be scattered throughout our code. So let&rsquo;s look at our Employee class. We can see that it has this Boolean for whether or not it&rsquo;s a manager. We can take that out of there and create a new class using inheritance we can create a Manager class that is an Employee, and then the other thing we can do is we can create, as well as this bonus, we want to be able to calculate the bonus based on the freight that&rsquo;s passed in our case. So, we&rsquo;ll create a public decimal SetBonus, let&rsquo;s say, and let&rsquo;s make this one only support Get. Bonus is protected and we have a SetBonus method that takes in freightUsedForbonus and we want to make this virtual and then we will say for an employee that bonus now equals freightUsedForBonus divided by 1,000, but for a manager we&rsquo;ll override that and we&rsquo;ll simply say that bonus is equal to the freight divided by 10 that was our logic that we used before. And this can actually be void it turns out, because it&rsquo;s doing all the work. Now we simply need to be able to create things as managers or employees as appropriate in our code. So if we look back at our program here, we&rsquo;re going to say that we get a new employee, and then based on whether or not it&rsquo;s got this particular row value, we&rsquo;re going to set it to something or the other. We can certainly create a factory method of some sort that takes in this row data and generates the correct class for us, but in this case we can simply move these things around. We&rsquo;ll save our employee. Actually, we&rsquo;ll say Employee, employee here, and then we&rsquo;ll specify in our if statement that employee = new Manager with a name = row 0 .ToString and that&rsquo;s all we really need. Otherwise, we can pull this block here and say that we equal a new Employee using our block we just snagged, and add them. Now that doesn&rsquo;t change this logic significantly. Let&rsquo;s see, there we go. But our foreach logic now makes more sense because now instead of having to do this check and ask, this is a violation of the Tell, Don&rsquo;t Ask Principle, because what we&rsquo;re doing is we&rsquo;re saying I&rsquo;m going to ask this whether or not it&rsquo;s a manager and then I&rsquo;m going to set something on it. And so this is a very common anti-pattern that you want to avoid. Instead, we want to just let our object do what it&rsquo;s responsible for and it should be responsible for calculating the bonus in this case or we could create another object that does it, but certainly our Main program shouldn&rsquo;t be doing this logic. So now we can simply call employee.SetBonus and we need to pass it in what the totalFreight value was and all the rest of this can disappear. And it eliminates some repeated logic where throughout our code we might be doing this inspection of whether or not an employee is a manager or not and doing some kind of different behavior based on that. Using inheritance and polymorphism, we&rsquo;re able to apply this right here in such a way that it does that generally and we can use that same pattern throughout our code. If we run the code, we see that we still get the same results that we got before. Here you can see managers get 20 grand, employees get $207.00, which is what we had to begin with.</p>

<p>Summary</p>

<p>This wraps up part 1 of the Don&rsquo;t Repeat Yourself Principle, one of the fundamentals of software engineering and a principle of Object-Oriented Design. To summarize, repetition breeds errors and waste. You want to try and refactor your code to remove repetition using a number of known refactorings, design patterns, and principles. I mentioned two books that I recommend. The first one is the Pragmatic Programmer: From Journeyman to Master, available at the URL shown here, and 97 Things Every Programmer Should Know, available at this URL. Thank you very much. This has been the Don&rsquo;t Repeat Yourself Principle Part 1 by Steve Smith for Pluralsight on-demand. Stick around and view part 2 where we&rsquo;ll show some additional refactorings of the code that we were looking at, as well as show how we can apply the DRY Principle to processes in addition to just code.</p>

<p>The Don&rsquo;t Repeat Yourself Principle, Part 2
Introduction</p>

<p>Hi, this is Steve Smith, and this is part 2 of the Don&rsquo;t Repeat Yourself Principle, one of the software fundamentals and part of the Principles of Object-Oriented Design course. In part 1, we defined the Don&rsquo;t Repeat Yourself Principle, we went through a number of demos showing how there was repetition in our code, we analyzed the code and looked for ways that we could improve it, and we made a checklist of problems that we found. We went through a number of refactorings to apply the Don&rsquo;t Repeat Yourself Principle and we didn&rsquo;t get through them all, so in part 2 we&rsquo;re going to continue with those and with this part we&rsquo;re going to have an emphasis on testability. So at the end of this section, we&rsquo;ll have our code refactored to a state where we can easily apply Unit Tests to it and we&rsquo;ll also examine some testing concepts such as mocking. Next, in part 3, we&rsquo;ll talk a little bit about Code Generation, some tools that you can use to eliminate repetition in your code and to discover repeat blocks of code, as well as how you can use automation to eliminate repetition in your software design and development processes.</p>

<p>Analysis</p>

<p>In part 1, we went through these first four sections. We eliminated some magic strings and values, we found duplicate logic in several methods, we eliminated some repeated if-then logic, and we used polymorphism instead of conditionals. Go ahead and watch part 1 if you want to see some of those refactorings in action. Now we&rsquo;re going to jump down to the testing and static method section, so look for, in this section, we&rsquo;re going to be talking about how we can use automated tests instead of just the manual testing that we had previously, and also we&rsquo;re going to eliminate some static cling and get rid of a bunch of static methods and replace those with methods that are more easily tested. Finally, in part 3, as I said we&rsquo;ll come back and look at some additional refactorings, find some duplicate code using a tool, and also get into that automation of our processes. Without further ado, let&rsquo;s look at how we can add some testability to our code.</p>

<p>Tests and Static Cling</p>

<p>Wrapping up our analysis of the application, we see that it has no tests. You may have noticed inside the various solutions that I&rsquo;ve been working with that there are projects there for Unit Tests and Integration Tests, but right now those have no actual tests within them. The only way that we&rsquo;ve been testing our code is through the use of manual tests or in this case we&rsquo;ve been just running the code over and over again, hoping that we still get the same result that we got when we started. As we add functionality, it becomes more and more expensive to verify that the results are correct, especially as the data gets larger or the number of different operations get larger, and if the time required to actually run the code gets longer and longer, our manual testing process gets more and more expensive as more and more time is wasted on these long-running queries. Another problem with this code when it comes to testing is the use of static methods. The static methods introduce tight coupling in our application because there&rsquo;s no way to replace, through Dependency Inversion or similar procedures, the code that&rsquo;s being executed within the static method. These are difficult to test because of these tight-coupled dependencies, which oftentimes lead to third-party infrastructure things that the code is tied to like a database, and it makes it very difficult to change the behavior without actually going in and changing the code. It also limits our ability to use object-oriented design techniques such as Inheritance and Polymorphism because static methods inherently don&rsquo;t support those, at least in the C# language. Now it&rsquo;s worth noting that there are some third-party tools that will go and do some tricks within the code to make it so that you can mock out or change what static methods do, but speaking only about the stuff that ships with the .NET framework and the types of code that you would typically use to test the code, static methods are a problem.</p>

<p>Demo Adding Integration Tests</p>

<p>Let&rsquo;s look at a demo of how we can refactor this code to eliminate the static cling or the use of static methods and properties, and also to add in some tests, and we&rsquo;ll look at some real quick Unit Tests and Integration Tests. The easiest thing to do with a tightly-coupled Legacy application that doesn&rsquo;t have a lot of abstractions, is to start out by adding some Integration Tests. So we&rsquo;ll look at our Integration Tests project where I&rsquo;ve got a Tests class and the first thing that we&rsquo;re going to want to do is verify that, let&rsquo;s say Extraction loads up the correct values for the things that it&rsquo;s doing, so Extract, we can see that it&rsquo;s trying to get invoices after a certain data, and then it&rsquo;s trying to get the employees also from the Northwind Table. So in this case, we can say something like ExtractShouldLoadInvoices, and let&rsquo;s just say that Should is our name, and then we can put in a public void LoadInvoices, and we&rsquo;ll call this a Test so it will run, and now we can go and try and test our code. So, let&rsquo;s rename our class here, Rename the file, and of course, there&rsquo;s no easy way to test our code at the moment because all the logic is inside the program, the program is marked as internal, and so it&rsquo;s very difficult to get to this code. So the first thing that we need to do is try and extract out the Extract method into something that we can work with. And so to start with that, we&rsquo;ll create a new class and we&rsquo;ll call this class ExtractionService, and we&rsquo;ll simply move this entire block of code into that Service. And we&rsquo;ll keep it all as a static method, and now here we just call ExtractionService.Extract. Now the problem is that our ExtractionService needs to actually pass back some of this data. This employeeTable needs to come back, this invoiceTable needs to come back, so instead of having a void, we&rsquo;re going to create a new result. We&rsquo;ll call it ExtractionResult, and it has a public DataTable InvoiceTable and a public DataTable EmployeeTable. There&rsquo;s a number of different ways that we could do this, but this one will work. And then in our method we&rsquo;ll say that we need a var result = newExtractionResult. And then we&rsquo;ll set this to be result.InvoiceTable, replace that everywhere. Similarly, the EmployeeTable will be Result.EmployeeTable, replace that everywhere. And then instead of void, we need to return an ExtractionResult, which means that down here at the end we return result, and here in our code we will also say var result is equal to this, make that public. Good, and then we need those to be on our local values, so we&rsquo;ll say that employeeTable = result and invoiceTable = result.InvoiceTable. Now we hope that that still works, so we&rsquo;ll try and build, we&rsquo;ll try and run. The code still runs with our manual test, so now we can go into our class here and we can do the same thing. We can say var result = (Typing) let&rsquo;s make sure we&rsquo;ve got our namespace, ExtractionService. there we go, get our namespace .Extract. Now you can imagine that I&rsquo;m going to be talking to a different database, so let&rsquo;s go ahead and we&rsquo;ll run this test right now and we&rsquo;ll watch it fail. So, let&rsquo;s go and run our Unit Test and it&rsquo;s failing right now because it could not load the assembly or one of its dependencies. Now at this point we can actually run our test and it should work because we&rsquo;re using hard-coded ConnectionStrings within our program. So when we talk to this database here, it&rsquo;s going to be talking to the same database that our live application talks to. Now obviously we&rsquo;ve got another to-do item to pull this out into some kind of a configuration value, and then within our IntegrationTest, we would change that out to talk to a test database, but for now let&rsquo;s go ahead and run this Unit Test and here you can see that we got our output. The other thing that we can then do to make our test actually valuable, is we can start asserting something about the results, so we can say Assert.AreEqual(result.EmployeeTable.Count, or rather .Rows.Count. And for now, we&rsquo;re just actually trying to put our system under test so that we know that it does what it does. So, we expect it to be some number and we&rsquo;re going to verify whatever that number is here in just a moment, so we&rsquo;ll change this to be InvoiceTable. We know it&rsquo;s not 0, we&rsquo;re going to set it to what it really is. So, 2155 is the number that it got back for invoices here. We&rsquo;ll set that. And we&rsquo;ll run it again, and we got 9 employees, so we&rsquo;ll set that here. And we&rsquo;ve got a successful test. So this is our first IntegrationTest now that we can run. And this basically verifies very little. It proves that we&rsquo;re getting back the number of rows that we expect and the reason why we expect them is because it&rsquo;s the amount of rows we get back currently. This is called a Fixing Test because it fixes what our application does and what we expect it to do at this point in time, and it lets us continue to make changes now, confident in the knowledge that when we run this test it&rsquo;ll verify that the behavior that the system currently does has not been changed. These are nice to have when you&rsquo;re going in and doing a large refactoring, because the purpose of a refactoring is to change how your code is designed and how it operates, but not to change its behavior. So you would expect that whatever it was doing previously, it&rsquo;s still doing. And so these are valuable from that point of view, however, they are very slow tests. If we look at the time that this test took, let&rsquo;s run it one more time, and we can turn on timings here. You can see that this test took about 1 second to run. Now it doesn&rsquo;t sound like that&rsquo;s too bad, but as we continue to add tests to this, we&rsquo;re going to have hundreds of tests and if our code takes 100&rsquo;s of seconds to run, it&rsquo;s going to get very, very slow to run these every time we want to do a check-in or every time we want to verify that our code still does what we expect.</p>

<p>Demo Adding Unit Tests</p>

<p>So the other thing that we want to do is add some Unit Tests to this code. So if we look here now at our UnitTest code, we can change what this class is doing to say something like ExtractShould as well. And what we want Extract to do is simply to get some data from these two Data Sources and we don&rsquo;t really care what that data is in this case. So we&rsquo;re going to do some additional refactoring in order to get to the point where we can do this test, but basically we want to have something like our extractionService, well first we need a method, so we&rsquo;ll create a method for our test and we&rsquo;ll say, ExtractShould GetDataFromInvoicesAndEmployees, make this a test, and then we can say var service = new ExtractionService, add our reference, and then we want to basically, this is going to use a pattern called Arrange, Act, so we&rsquo;ll say var result = service. Actually we don&rsquo;t have that as a non-static method yet, but we will in a moment. So we&rsquo;ll just leave this out of here for now. And then we&rsquo;ll have our Assert. And in our Assert we can verify that the state of the code, in this case we&rsquo;ll say something like Assert.IsNotNull, and it&rsquo;s going to be our result. So for now we&rsquo;ll just say new Object, right. So there&rsquo;s not much here yet. Let&rsquo;s go make it so that we can actually run this UnitTest and verify that it&rsquo;s doing the interactions that we expect. Now the thing about the UnitTest is that it&rsquo;s not going to have any kind of a reference to System.Data, it&rsquo;s not going to talk to the database at all, and the way we&rsquo;re going to achieve that is through the use of something called mock objects, and we&rsquo;ll see how those work in just a moment, or through the use of a fake, which we could also use, so we&rsquo;ll show both of those. So let&rsquo;s go back to our program. We&rsquo;ve got this ExtractionService. At this point, let&rsquo;s go ahead and move that to another file and we&rsquo;ve got our result. We&rsquo;ll move that to another file as well. And in our Service, we can see that it&rsquo;s talking to a database, it&rsquo;s doing these two commands. Basically it&rsquo;s going to need to talk to an InvoiceTable, and it&rsquo;s going to need to talk to an EmployeeTable to do these things, so I&rsquo;m going to go ahead and say that this is a non-static method as our first refactoring and let&rsquo;s see what that breaks. Well first off in Program I&rsquo;m going to have to have this be a new ExtractionService for that to work and then same thing in our IntegrationTest we just wrote, and then it&rsquo;s a good idea to run all of our tests to verify everything still works, and they still run. So we can continue with our refactoring. So we come back to our Service, which is now non-static, and we need to say that it depends on some things. so we&rsquo;re going to say, well, we need a constructor, and our constructor is going to say that we need an interface for, I think, something like an IInvoiceRepository and an IInvoiceRepository needs to be able to return back, let&rsquo;s say, a DataTable to keep things easy, so it&rsquo;s going to have a DataTable ListInvoices. We could specify the date that we want, but for now let&rsquo;s leave that hard-coded and we&rsquo;ll do the simplest thing that works, and we&rsquo;ll also need a drive type of this. We&rsquo;ll call this a SqlInvoiceRepository and we&rsquo;ll implement the member and then in here we basically want to refactor out all the stuff that&rsquo;s using a connection, grab all that, stick it into our ListInvoices, and once we get to the point where we have an InvoiceTable here, we want to return it. Actually that&rsquo;s not quite right. We need a Table there and then we need to Fill it. So we&rsquo;ll say var table, and then we&rsquo;ll Fill that table. And then we&rsquo;ll return that table, right? Now once we have that, we can come back in here and we can say you know what, I need an IInvoiceRepository called invoiceRepository. I need a local variable set to that, so I&rsquo;ve got now an invoiceRepository that&rsquo;s set to that. And I need this to work even if nothing is passed in so that my code still works the way it always did. So we&rsquo;re going to have a public ExtractionService empty constructor, which calls this and passes in a new SqlInvoiceRepository, and then does nothing else. So this ensures that my code still works the way it always did. This is some poor man&rsquo;s Dependency Injection here. And then in our code we only need this foreach once we get our InvoiceTable, so pull this out. We need this result and we need to say result.InvoiceTable = _invoiceRepository.ListInvoices. And we can now get rid of this big using block. Next, we want to do the same thing with the employees, so we&rsquo;ll just do, let&rsquo;s get these out of our file, so we&rsquo;ll move this to another file, come back to our Service, move this to another file, come back to our Service, create our new interface for employees. So we have a public interface IEmployeeRepository, and it&rsquo;ll have a DataTable for ListEmployees. Now we just need to create a drive type from that. We&rsquo;ll call it SqlEmployeeRepository. We&rsquo;ll implement the members and we&rsquo;ll do the same thing we did before, we&rsquo;ll pull out all this code here and drop that in, and we&rsquo;ll need to have a table that we Fill, and of course, you can see there&rsquo;s some duplication here that we would get rid of through methods already shown in other demos. We&rsquo;ll Fill the table, we&rsquo;ll return that table, and then change our code here to take in that Repository, So we have an IEmployeeRepository employeeRepository. We&rsquo;re going to introduce and initialize a field EmployeeRepository, just as we did before. We&rsquo;re also going to change our poor man&rsquo;s injection to automatically inject a SqlEmployeeRepository, so our code continues to work as it did before. And then we need to say that our code here, we have to get rid of all the SQL stuff and those closing curly braces, and we just need to say that result.EmployeeTable = _employeeRepository.ListEmployees. Now another instance of Don&rsquo;t Repeat Yourself that you might notice here that I might change at some point is I&rsquo;ve got employeeRepository and then I&rsquo;ve got ListEmployees, that gets to be kind of redundant, so it&rsquo;s pretty common to simply call this a List method instead, and that way you know its listing employees because, well, it&rsquo;s an employeeRepository. For now, we&rsquo;ll leave it the way it is and verify that we can still run our code. It still runs. Of course, we should be also able to verify that by running our Unit Tests, which right now is just this IntegrationTest, and it still runs, which brings us now back to our UnitTest. So our UnitTests, let&rsquo;s go ahead and rename our file, and that&rsquo;s good. Now we&rsquo;re able to actually call our Service, so call service.Extract and get some results back. And since we didn&rsquo;t pass in any kind of variables in here, right now we&rsquo;re going to be doing the same thing as our IntegrationTest. So now we can verify result and running this should run just like our IntegrationTest, and it does. And you can see we get all this data from our actual database. We don&rsquo;t really want to be talking to the database, though, at all. We really just want to be verifying that our methods were called, so what we&rsquo;re going to do is we&rsquo;re going to create a fake repository for invoice, so that will say public class FakeInvoiceRepository inherits from IInvoiceRepository, and we&rsquo;re going to implement that member. And in this case, we just want to verify that this was called. So we&rsquo;re going to return a new DataTable with nothing in it, but we&rsquo;re going to have a Boolean here, so we&rsquo;ll have a public boolWasCalled = false, and then we can set WasCalled = true. We&rsquo;ll do the same thing for our Employee class, so we&rsquo;ll have a FakeEmployeeRepository, which inherits from IEmployeeRepository, implement its member, and here we&rsquo;ll say WasCalled = true, return new DataTable. Now in our UnitTest, we can pass in these particular repositories. So we&rsquo;ll say var invoiceRepository = new FakeInvoiceRepository, var employeeRepository = new FakeEmployeeRepository, and we&rsquo;ll pass these into our code now. This is using the Strategy Pattern to inject these dependencies and then once we go to Assert, I&rsquo;m sort of Asserting against the result, this is called state-based testing where we&rsquo;re testing that the state of our system is what we expect. What we&rsquo;re going to be doing is something called behavior-based testing. We&rsquo;re going to verify that the code under Test, this Extract method, did the things that we expected it to do in terms of its interactions with other code. So all we want to Assert here is that invoiceRepositoryo.WasCalled, and Assert, That(employeeRepository.WasCalled) as well. And now we can run this test, and you can see that it ran in 3 milliseconds and came back as true, showing that these two things were, in fact, called and it did not talk to the database. So that&rsquo;s an example of refactoring our code to allow for behavior-based testing. Now if we looked at our Service again and said that maybe based on the invoices we would or would not call the EmployeeTable, we can see how that might change our UnitTest. So we could say something like, if (result.InvoiceTable.Rows.Count &gt; 0), then we expect to call this. This is the kind of logic that we would be testing with our behavior-based test, because now we can come back to our UnitTest and we know that we&rsquo;re passing back an empty DataTable for Invoice, so we&rsquo;re going to expect this to be false in that case. So now we can run this UnitTest and see that it does what we expect. So that&rsquo;s an example of how we would test the behavior of the method under Test, the Extract method, separately from what the actual data is that it might be returning. And that wraps up our changing of static to instance methods, as well as some refactoring to get these interfaces. So we can move this interface to another file, go back to our Service, move our Repository to another file, and then before we&rsquo;re done here let&rsquo;s look at what we have. We&rsquo;ve got now our program has gotten a little bit smaller, it no longer has the extraction stuff in it, instead it&rsquo;s using this ExtractionService. We&rsquo;ve got a couple of invoices, which we&rsquo;d probably move to a separate folder. We have a couple of implementations of those interfaces, which we would probably move to a separate folder or ideally to a separate assembly that would be responsible for our DatatAccess. And now we&rsquo;ve got both IntegrationTests that talk to the database, as well as UnitTests that verify the behavior of the particular method that we&rsquo;re looking at.</p>

<p>Demo Mock Objects</p>

<p>Let&rsquo;s talk about how we could use a Mock object instead of having to write our own Fake objects to change how we would do this UnitTest, and then we&rsquo;ll be done with this section of the module. So using a Mock framework like Moq, or mock or mo-q, you can easily create Mock versions of these interfaces that you can then use. So in the case here where we want to verify that when we get back an empty result from the InvoiceRepository, that we do not call the EmployeeRepository, we would implement that something like this. First we need to change our invoiceRepository to make it so it is a Mock one, so we&rsquo;ll say this is a new Mock of Then we want to verify what this Mock is going to do, so we&rsquo;ll say invoiceRepository.Setup, and we&rsquo;re going to say that when the ListInvoices is called, we want that to return a new DataTable. Then we can do our Service so that it takes in these things with Moq the actual object we want is under the .Object property of our Mock, so we&rsquo;ll say .Object for both of those. We&rsquo;re going to go ahead and call this. And now instead of our Assertion that we have this WasCalled property, we don&rsquo;t actually have one of those on our Mock object. Instead, we&rsquo;re going to say something like InvoiceRepository.Verify and we want to say I, such that I.ListInvoices, and then we&rsquo;ll say Times.Exactly, (Typing) 1 time, and then we also want to verify in this case that the employeeRepository has a method called ListEmployees. We want to say it was called Times.Never because we don&rsquo;t want it to have been called. In the Unit Test, in here you see it was successful. So looking at this code, you can see it&rsquo;s doing pretty much the same thing we were doing with our Fake objects here, except that you can imagine that we would end up writing a lot of these Fake objects if we were doing this over and over again within our code. By using a Mock framework like Moq, we were able to create these Mock objects, specify the behavior we expected from them, then pass them into our system under test, in this case our ExtractionService, run our code, and then verify that the interactions with the collaborating objects, these two repositories, happened exactly the way we expected them to, with one call being made to the invoiceRepository.ListInvoices. And because of the result that it returned back, a DataTable with no Rows, we were able to see that ListEmployees was never called, and that behavior was this behavior we added here as you recall. Alright, so that&rsquo;s how you can use Mock objects. Obviously we can go into more detail on that in another course.</p>

<p>Summary</p>

<p>So to summarize, it&rsquo;s important to realize in our software development that repetition is a source of errors and waste. We should avoid repetition within our code by refactoring it so that there is only one canonical representation, and one of the fundamentals that I&rsquo;ve found to be the most useful in doing this is the use of certain design patterns such as the Template Method Pattern or the Command Pattern, You can learn more about patterns from Pluralsight&rsquo;s Pattern Library, and also the Dependency Inversion Principle, which we covered already in this Principle of Object-Oriented Design Course. Some books that I recommend reading for additional learning about this topic is The Pragmatic Programmer: From Journeyman to Master, as well as 97 Things Every Programmer Should Know, which has a bunch of very useful tips and stories from experienced software developers. Thank you very much. This has been part 2 of the Don&rsquo;t Repeat Yourself Principle, part of the Principles of Object-Oriented Design Course. I hope to see you in class soon.</p>

<p>The Don&rsquo;t Repeat Yourself Principle, Part 3
Introduction</p>

<p>Hi, this is Steve Smith, and this is Part 3 of the Don&rsquo;t Repeat Yourself Principle. I feel like I&rsquo;m repeating myself a little bit with these title slides. This is one of the software fundamentals and it&rsquo;s the final module in the Principles of Object-Oriented Design that&rsquo;s related to the Don&rsquo;t Repeat Yourself Principle. In Part 1, we went through the definition and a bunch of demos on refactorings, we did some analysis of our code and we cleaned it up a bit. In Part 2, we continued that process with an emphasis on testability and adding tests and using Mocks to make it so that our code was easily tested in isolation. Now in Part 3, we&rsquo;re going to focus here on a couple of aspects, specifically Code Generation and automation of our processes so that we can eliminate repetition in those areas as well, which will result in a more consistent build, and better quality software that we&rsquo;re going to be able to deliver more consistently and frequently.</p>

<p>Analysis</p>

<p>So, we&rsquo;re going to start off with one more demo showing how we can eliminate some repetition in our code and then we&rsquo;re going to jump right into the tools that we talked about. So this is the section that we&rsquo;re going to be looking at right now.</p>

<p>Repeated Execution Patterns</p>

<p>So when we talk about Repeated Execution Patterns in our code, what we mean is areas where we see the same kind of pattern of code being done multiple times, either within the same method as we see here at the top, this is part of our Main method where we first do an Extract and then a Transform, and then a Load, but each one of these has a very similar Console or Logging statement that&rsquo;s saying when it began and when it completed, or they could be in multiple methods. For instance, here we see some very standard code for opening up a SqlConnection followed by the actual command that&rsquo;s being applied to the SQL database, and this same pattern is repeated in multiple placed in our code as well.</p>

<p>Demo: Refactor using Action of T</p>

<p>Let&rsquo;s look at how we can refactor our application to eliminate this repetition. Looking at repeated execution patterns in our application, we immediately see that the Main method is doing the same thing over and over again, where it initially writes out a Log message, calls some method, and then writes out another Log message. This is repeated three times in our Main method, and if we had this program continuing to grow, we can imagine that as we added additional methods that it might call, it would continue to grow and we would have a lot of repetition in how this pattern is followed. The first step in refactoring this would be to extract out this method. So we can use the Extract method Refactoring, and generate a method that we&rsquo;ll just call Command for now. And so in our Command, we&rsquo;re going to write out our WriteLine, then call the Extract Command, and then finally write out the next WriteLine. So the next step is to change this so that instead of being this particular command, we&rsquo;ll call this something else. For instance, we could say this could be StepInProcess, and then the actual command that it&rsquo;s going to follow is a particular action. So we&rsquo;ll pass that in now since we want to be able to vary this particular line, while keeping these other lines more or less the same. So in this case, we&rsquo;ll just call Action, and then here we would have to pass in our Extract Command and that will allow us to do pretty much the same thing we were doing before and we can test this using our manual testing process, and we see that the application continues to run as it did before. At this point, the next step would be to add support for these next two lines that are repeated as well. And so in order to do that, we&rsquo;ll simply duplicate this call to StepInProcess and pass in the other method names, Transform and Load. With that, we&rsquo;ve eliminated the repetition of how the logging is done, except that now we&rsquo;re seeing that the extract, and extract here, needs to change as well. So we can change this by simply putting in a variable in this case and for that variable, we&rsquo;ll use the action.Method.Name instead, and in this case we&rsquo;re going to get a slightly different formatted result, but that&rsquo;s okay because this is just logging. We&rsquo;ll save this and run it and you can see that it still runs as it has before and here we can see it Finished Extract, it Finished Transform, Beginning Load. You can see those messages are still being output. So now we have a little bit of repetition here, in that we see that we&rsquo;re calling this StepInProcess, that StepInProcess, the next StepInProcess. It would probably be better if we could refactor that as well, just so that if we did get a much larger application where we were having to orchestrate a whole lot of different steps in a particular workflow, we could do that in a more maintainable fashion. The easiest way to do that is to take those steps and apply a loop to them. So, we&rsquo;re simply moving this out of the Main section and saying something like, foreach, let&rsquo;s call this GetSteps, and we&rsquo;ll say this is a step. Then we&rsquo;ll just say StepInProcess(step). Right, and at that point I don&rsquo;t really like the name StepInProcess. Let&rsquo;s call this ExecuteStep. And then we need to get Steps to be created for us, so we&rsquo;ll create this method GetSteps and it&rsquo;ll return an IEnumerable, which is correct. And here we can just say that we want to yield return Extract, and then we&rsquo;ll do yield return Transform, and yield return Load. So with that, we&rsquo;ll be doing the exact same thing as we had before, but now we&rsquo;ve moved this data or rather this logic from our Main method and put it into this GetSteps method that we could push into a different application assembly if we wanted to, and it&rsquo;s making it so that our Main method doesn&rsquo;t have the responsibility of determining which steps or what order the steps are done in, that&rsquo;s now the responsibility of this method here. Let&rsquo;s show that that still works, and it does. You can see we&rsquo;re still Finish Transform, Beginning Load, Finish Load, as before. Now this yield keyword, if you&rsquo;re not familiar with it, it&rsquo;s a C# keyword that allows this particular method to yield its result back to the calling method and then as the foreach enumerates through this method, it&rsquo;ll continue to call into this. So it&rsquo;ll first call this one, and then it will call this one, and then it will call this one. Now if that syntax is strange to you, another option would be to simply do something like this, return new List where we&rsquo;re going to say that this contains Extract, Transform, Load, and since List is an enumerable, we could do this as well, and this would run as well. So it&rsquo;s just a matter of your preference whether you want to create a list to return or simply use this yield syntax. Yield syntax is a little bit smaller, so I&rsquo;m going to go with that, but it really would make no difference to the application.</p>

<p>Demo: Refactor Data Access</p>

<p>Now let&rsquo;s look at the next area where there&rsquo;s repetition in logic in this code, and that&rsquo;s our data access code. You can see here where we&rsquo;re using a Connection and in that same method we&rsquo;re using a connection again. In our Transform, we&rsquo;re not really doing anything with the database, but then in our Load we&rsquo;re using a Connection as well, using another connection as well. So you can see there&rsquo;s a lot of places where we&rsquo;re doing this kind of logic, the same thing with these commands. The easiest way to refactor that is going to be to provide some kind of an abstraction over our Data Layer. A tool that I&rsquo;ve used for many years now is the SqlHelper tool here, and you can find this from the Data Access Application Block. You can reference that DLL directly or you can take the code and drop it into your own assembly, which I&rsquo;ve done here. And so this is all code that I didn&rsquo;t have to write, that I pulled directly from the Data Access Application Block SqlHelper, along with a few other Helper classes that you can see here in this Data folder. And then within our program, anywhere we want to work with the SQL Database using the SqlHelper, we can refactor this block of code here that&rsquo;s doing all of this work to load up an invoiceTable, and we can refactor that to use the SqlHelper with pretty much one line of code. So we know we have an invoiceTable that we want to set to be full of this data, so we&rsquo;ll start off with that. And we&rsquo;ll say this equals SqlHelper, and we&rsquo;ll add our reference. And this is going to use the ExecuteDataSet method. In later versions I think there might be an ExecuteDataTable, but it&rsquo;s easy enough to just grab the first table off the DataSet. Now we need a Connection, Command, Command Text, and some Parameters. So for our Connection, we can just pass in the ConnectionString. So since the refactoring of the connectionString is a separate exercise, we&rsquo;re going to continue to just use our hard-coded magic string here, but of course, you would want to change that in your actual final version of this code. And then we want to pass in the Command Type and this is simply going to be CommandType.Text as our default. And to make this a little bit easier to read we&rsquo;ll put these each on their own line, right. Now we need the actual Command we want to run, so I&rsquo;m going to pull that out so that it&rsquo;s still a separate string. So we&rsquo;ll grab this right here, throw it up above, and reference it here as a parameter. myQuery. And then we need some parameters. I could pull the parameters out separately as well or I can just put in here new SqlParameter array that includes a new SqlParameter, and that parameter is this guy right here. And of course now we need to make that a DataTable. So, as I said, we&rsquo;ll just grab the first Table off the DataSet and we can get rid of that because it can infer the type. And then with that we can get rid of all of this and these, and these, and reformat. Alright, so now this is all we have to make that call instead of what we had before. We could further, of course, get rid of the duplication of the call here and move some of this into a separate class, but just by doing this initial refactoring we&rsquo;ve eliminated all of those using blocks, and the direct access to the ADO.NET code. If we were to apply this same change here as well, this is also a DataTable, so it would be pretty trivial to make that change. In fact, let&rsquo;s go ahead and do it just to show you. We&rsquo;ve got a string myQuery we should probably just reuse that so we&rsquo;ll grab this and put it right here and I think the only things that are going to change is our actual query we&rsquo;ll need to change. We&rsquo;ll paste that in. Our ConnectionString stays the same, and our command in this case doesn&rsquo;t even have any parameters, so we can eliminate the need to pass in any parameters. And then we simply get rid of all this code here that was working on filling up our Table. Of course, that&rsquo;s the employeeTable this time, so let&rsquo;s make that change as well. And with the employeeTable filled, we can do our work on it, we can get rid of a few more angle brackets, or curly brackets, rather, reformat our code a little bit, and now our logic is much, much simpler. We can fit the entire method pretty much on one screen here, which is always nice so you can see everything that&rsquo;s going on. And there&rsquo;s no more duplication and there&rsquo;s much less nesting of our curly braces with those using statements. And we know now that we&rsquo;re never going to forget a using statement because SqlHelper is already vetted and trusted as a Data Access wrapper that makes sure that it handles those cases. So, this is the kind of thing that you can eliminate duplication of through the use of a third-party library or your own, sort of, Utility class that you&rsquo;ve extracted out the logic of the duplicated code into. Even better than using SqlHelper, in this case I would recommend using some kind of an object-relational mapper, for instance, LINQ to SQL or LINQ to Entities or a third-party one, because that will even further eliminate this tight coupling to the SQL internals. So right now we still have these magic strings for our SQL queries. I would much rather see that turned into something like a LINQ expression where I have some actual type checking of the values and I can do refactorings against those property names and have them applied throughout my C# code, without having to go in and remember to look at what these SQL magic words might mean, for instance, the Table name or the Column name. If those change, I&rsquo;m not going to have a refactoring tool in my C# code that&rsquo;s going to be able to detect those changes and fix those.</p>

<p>Demo: Find Duplicate Code - Atomiq</p>

<p>In the original version of our code, we have a lot of duplicate copy-pasted blocks of code. In fact, there&rsquo;s too many of them to simply list on a power point slide, so we&rsquo;re going to use a commercial tool that there&rsquo;s a good free version of as well, called Atomiq. Now in the interest of full disclosure, I actually own the company that produces Atomiq, so take anything I say with, you know, a grain of salt, because I&rsquo;m biased, but also realize that there is a free version of this tool that you can use, and it&rsquo;s really simple and easy to get started with it. Let&rsquo;s go ahead and see how we can apply this tool to find some duplication. So when you first run Atomiq, the first thing that you&rsquo;re going to need to do is open up the project that you want to use and then create a new project where you specify the folder that you want to use, the types of files you want to look at, what the similarity is in terms of the number of lines of code that should be similar for it to pick it up, and then you can exclude certain files where you know there&rsquo;s going to be a lot of repetition, because for instance, designer files are often generated Code so you can ignore those. I already have a project that I&rsquo;m going to open up and this is the DRY Demo project. And so here you see it opens up now. In the case of this demo, we only have pretty much one C# file, and that&rsquo;s our Program.cs. When we&rsquo;re done, we might have multiple different files and in any real application you would, of course, have many different files, but in this case there&rsquo;s just one. Now one of the cool visual pieces of Atomiq is this Wheel view, and unfortunately with only one file, it makes a pretty little diagram, but it doesn&rsquo;t really show you quite the same value that you would get if you had many files. The way this works is we have all the different files arranged around the outside of the ring and then these two items here represent different files and then each one of these is a line running from one file to another. Now in this case, you can see they all are running around the outside because they&rsquo;re all communicating from one file to that same file, and so you see each one says same file. I&rsquo;ll show you a real application and what this would look like, when I&rsquo;m done here. Looking at our code, we can see these are all the duplicates that it found. There were 28 blocks and 88 lines of code, total, with one file, and now we can go and explore our code. So we can auto-hide this to give us a little more room, and we can see that this section of code right here where we&rsquo;re saying using, myConnection, ConnectionString, myQuery, this is repeated and it&rsquo;s repeated in multiple times, so each one of these lines is showing us a different location where that&rsquo;s repeated, and then down here we can see those two blocks and how similar they are. Now in this case they&rsquo;re identical, but Atomiq will also detect sections where the code isn&rsquo;t identical, but it&rsquo;s very, very similar. And over here we can explore and see other areas where we found duplicate logic. For instance, when we&rsquo;re adding our parameters, that&rsquo;s duplicated as well, and each one of these we can see here what the duplication is that was found. So in this case, you can see that the use of RunDate and ShipperName was the same in both of these instances. Let&rsquo;s take a look at what Atomiq would show us for a real application. I&rsquo;ve loaded up the nservicebus application. Let&rsquo;s re-analyze it. I&rsquo;ve set the similarity length to 6, which is the default for Atomiq. We&rsquo;ll say OK and it&rsquo;ll analyze the files. Nservicebus is an open source tool you can use for adding messaging to your application and it&rsquo;s a very mature application, it&rsquo;s been around for many years. We can see here&rsquo;s the view now within Service bus and all the different things where it found duplicate blocks of code. It&rsquo;s actually a very well-designed application from what I&rsquo;ve seen and so you&rsquo;ll see there&rsquo;s very few large sections of duplication here. Most of these only have a small amount of duplication and, for instance, in this case you can see it&rsquo;s where we&rsquo;re setting some properties within a test, etc., but it will let us see a nicer view of the Wheel. So when we open up the Wheel now, you can see here, these are the different sections, namespaces, and classes, and files within the application, and in each one of these lines represents a set of duplicate code between one class and another. So here you see that we&rsquo;ve duplicated code from the NHibernate tests and the SagaPersisters in the Hibernate test. Both of those are coming out of test projects, so we&rsquo;re probably not too concerned with that duplication. These types of views here represent same file duplication, just like we saw within our original app. But overall what you want to avoid is a lot of lines passing through the center of the Wheel. And if you have a little bit of these running around on the outside where duplication within the same file, especially if they&rsquo;re inside of a testing folder, it&rsquo;s not a huge concern. Within our real application, we want to try and minimize how much duplication there is, however. So that&rsquo;s Atomiq, again, there&rsquo;s a free version you can get or I think it&rsquo;s like 25 or 30 dollars or something if you buy it, and it&rsquo;s a nice tool that you can run in order to look for duplication within your code.</p>

<p>Code Generation</p>

<p>When looking at duplication in our code, one of the things that we could consider is the use of code generators. Visual Studio has great support for code generation through the use of T4 templates. And these custom code generation templates are, you know, used within Visual Studio and are also built into several of the products that you can use such as Entity Framework. So if you use Entity Framework, you&rsquo;re already using these T4 templates and you can customize the kind of code that they produce by changing the templates. If you use an object-relational mapper tool like LINQ to SQL or Entity Framework, as well as others like nHibernate or LLBLGen, these reduce repetitive data access code and eliminate a lot of the common errors, and also our form of code generation. In most cases, they point at your database and generate a set of Entity Classes, as well as code to manipulate those entities in a way that eliminates your need to hand-code all of that data access logic. A number of commercial tools are available that also are devoted to code generation, including CodeSmith, CodeBreeze, and CodeHayStack, which you might check out, among others.</p>

<p>Repetition in Process</p>

<p>The last thing that we want to discuss here in our Don&rsquo;t Repeat Yourself Course, is the types of repetition that occur in your process. If you look at your testing, performing testing by hand is tedious and wasteful. If you look at your builds, performing builds by hand is tedious and wasteful. If you look at how your deployment process works, you&rsquo;ll find that performing deployments by hand is tedious and wasteful. In fact, you might see some repetition in this particular slide where we could just say that performing whatever by hand is tedious and wasteful. So if we have things that can easily be automated, we should do so. And in our process, the things that can be automated include testing, building, and deploying our application. Let&rsquo;s look at a quick demo that shows how we can automate these processes.</p>

<p>Demo: Automation with MSBuild</p>

<p>When it comes to automation, MSBuild is a very powerful tool for automating a lot of the tasks that we have to do when it comes to building our project, testing our project, and even deploying our project. So first of all, let&rsquo;s look at a simple MSBuild project file and go through some of the properties that it has. Here at the top there&rsquo;s a PropertyGroup where I&rsquo;m defining what my output path will be and also the name of the project, because I use the same template for many different ClickToBuild projects. Then within here, I&rsquo;ve got a target named DebugBuild, which is simply going to do a Clean and a Build on my project using its project name and using the Debug configuration. One of the things that makes MSBuild very powerful as a build tool is the fact that it supports dependencies between these various tasks or targets, and so the next target is called BuildAndTest, which depends on DebugBuild and then it&rsquo;s going to do an Nunit call to run my Unit Test, and then another Nunit call to run my Integration Test. Then I have a ReleaseBuild that depends on BuildAndTest being successful and it just does a Clean and a Build in Release mode now of my project. And lastly, if I want to Deploy, I can use this Deploy target, which depends on ReleaseBuild, so it will only work if all my tests pass and my ReleaseBuild is complete. And it will copy my output to the Deploy, whatever path I&rsquo;ve set for that Deploy path. So if we look at this folder, let me pull it up here. So if we look at this folder, we can see that we have our Build.proj file, as well as a ClickToBuild and a Build.bat. Let me show you those real quick. ClickTobuild simply calls Build.bat with the ReleaseBuild target being passed in and then it pauses, which is going to require me to press Enter in order for the window to disappear. And Build.bat simply calls MSBuild and passes in the Build.proj and the /t parameter, which is for specifying the target with whatever gets passed into it. So with all that, I can now come in here to my project and I can run ClickToBuild and we can watch it execute. And see that it succeeded. So what this did is it ran our Build with the DebugBuild doing a Clean and then a Build. Next, it ran our Unit Test, and then it finally ran the Integration Test and then the ReleaseBuild as well. I don&rsquo;t have enough room in the buffer to show you all of that. We could pipe this of something if we wanted to see it, but you can see that it all ran with one click. And the nice thing about this is if I extract this out from SourceControl and then just run it, in this particular application I&rsquo;m having to use a Northwind database that would need to be set up, but assuming that Northwind was set up on the local host of whatever computer I was on, this should work. Now if you&rsquo;re grabbing this sample file yourself and trying to run it, that&rsquo;s the one thing you&rsquo;re going to have to do is set up Northwind on your database and run the SQL Script that&rsquo;s there as well, and then this should work for you as well, as long as you have Northwind and .NET 4 installed. ClickToDeploy, if we look at what this is doing, as you might expect it&rsquo;s simply going to call that same Build.bat file, but now it&rsquo;s going to pass in Deploy and we&rsquo;ll see that this produces an output of our application. So when we run ClickToDeploy, it&rsquo;s going to do everything the other one did including running our Unit Tests and Integration Tests and when it&rsquo;s finished you can see that we now have a Deploy Folder, and in our Deploy Folder we have our application, built in Release mode, that we can go ahead and run and see that it works. So that&rsquo;s an example of showing how you can automate your process of compiling and testing your application using MSBuild. The next step would be to have this happen automatically whenever you do a check-in and it&rsquo;s something that you can do easily with Microsoft&rsquo;s Team Foundation Server or with third-party tools such as Jetbrains, TeamCity or CruiseControl.net.</p>

       </div>             
    
<div class="row">
      <div class="small-offset-1 small-10 columns">
        <div id="disqus_thread"></div>
        <script type="text/javascript">                        
        var disqus_shortname = 'hey-its-alex'; 
        var disqus_developer = 1;
        </script>

        <script type="text/javascript" src="http://disqus.com/forums/antzucaro/embed.js"></script>
        <noscript><a href="http://antzucaro.disqus.com/?url=ref">View the discussion thread.</a></noscript><a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </div>
    

          <footer>          
          <p><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">All content on this blog is the creation of <a xmlns:cc="http://creativecommons.org/ns#" href="http://localhost:1313/" property="cc:attributionName" rel="cc:attributionURL">Hetal Patel</a> unless stated otherwise</span>. Have fun.
          </p>
        </footer>
      </div>
    </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-32186861-1', 'heyitsalex.net');
  ga('send', 'pageview');

</script>

<script data-no-instant>document.write('<script src="http://'
        + (location.host || 'localhost').split(':')[0]
		+ ':1313/livereload.js?mindelay=10"></'
        + 'script>')</script></body>
</html>
