<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on </title>
    <link>http://sh33tal.github.io/post/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 12 Jun 2015 05:20:03 +0000</lastBuildDate>
    <atom:link href="http://sh33tal.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>My C# Tips</title>
      <link>http://sh33tal.github.io/post/My%20Tips/</link>
      <pubDate>Fri, 12 Jun 2015 05:20:03 +0000</pubDate>
      
      <guid>http://sh33tal.github.io/post/My%20Tips/</guid>
      <description>

&lt;h3 id=&#34;the-null-coalescing-operator:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;The Null Coalescing operator&lt;/h3&gt;

&lt;p&gt;The null-coalescing operator can simplify our If statements when we need to check for the existence of a null value and provide some other default. If we don&amp;rsquo;t use the null-coalescing operator, we typically end up with If statements that look something like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        if (name == null)
        {
            result = &amp;quot;no name provided&amp;quot;;
        }
        else
        {
            result = name;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now Let using the null-coalescing operator.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var name = &amp;quot;Sarah&amp;quot;;

        var result = name ?? &amp;quot;no name provided&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we set a name and then we want to get a result. What we want is if the name is not null then to just use the name. Otherwise, use this default string. The ?? here signify the null-coalescing operator.&lt;/p&gt;

&lt;h3 id=&#34;testing-char-unicode-validity:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Testing char Unicode validity&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s useful to check whether a character is valid or not. To do this, we can use the static GetUnicodeCharacter method of the char struct. To use this method, we pass in a char and we get back a category. To test whether the character is valid, we check this Category is not equal to the OtherNotAssigned category.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var validCharacter = &#39;q&#39;;

        var ucCategory = char.GetUnicodeCategory(validCharacter);

        var isValidUnicode = ucCategory != UnicodeCategory.OtherNotAssigned;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;isValidUnicode is true because at the moment we&amp;rsquo;re comparing the lowercase letter q.&lt;/p&gt;

&lt;p&gt;If we cast from an integer and convert this to a char, we could end up with something that is not a valid Unicode character.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var invalidCharacter = (char) 888;

        ucCategory = char.GetUnicodeCategory(invalidCharacter);

        isValidUnicode = ucCategory != UnicodeCategory.OtherNotAssigned;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The category that we&amp;rsquo;ve got is the OtherNotAssigned category and isValidUnicode is now false. So the GetUnicodeCategory method is a useful one whenever we&amp;rsquo;re dealing with Unicode conversions that may fall outside of the valid set of Unicode values. Unicode categories include other useful things. We can find out whether the categories are currency symbols, enclosing marks, letter number separators, punctation, and a category such as uppercase letters.&lt;/p&gt;

&lt;h3 id=&#34;creating-random-numbers:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Creating random numbers&lt;/h3&gt;

&lt;p&gt;When we create a new random instance without specifying a seed value, it uses the current system time as the seed value. Because the system clock is limited in its level granularity, if we create two random instances close together, they may be initialized with the same seed value and hence will produce the same sequence of numbers. in the example below I&amp;rsquo;ve created two random instances, r1 and r2, and then I simply generated 5 numbers from that random instance. I&amp;rsquo;ve then done the same thing again, but for the r2 instance.&lt;/p&gt;

&lt;p&gt;var r1 = new Random();
            var r2 = new Random();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Debug.WriteLine(&amp;quot;r1 sequence&amp;quot;);
        for (int i = 0; i &amp;lt;5; i++)
        {
            Debug.WriteLine(r1.Next());
        }


        Debug.WriteLine(&amp;quot;r2 sequence&amp;quot;);
        for (int i = 0; i &amp;lt;5; i++)
        {
            Debug.WriteLine(r2.Next());
        }           
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The r1 sequence is identical to the r2 instance, the same for the rest of the numbers in the sequence. This is because the 2 random instances have been created so close together that the same seed value was used from the system clock.&lt;/p&gt;

&lt;p&gt;Below we&amp;rsquo;re still creating effectively a sequence of 10 random numbers, but this time we&amp;rsquo;re just using a single instance of the random class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [TestMethod]
    public void MoreRandomNumber()
    {
        var r1 = new Random();            

        Debug.WriteLine(&amp;quot;r1 sequence&amp;quot;);
        for (int i = 0; i &amp;lt; 5; i++)
        {
            Debug.WriteLine(r1.Next());
        }

        Debug.WriteLine(&amp;quot;more r1 sequence&amp;quot;);
        for (int i = 0; i &amp;lt; 5; i++)
        {
            Debug.WriteLine(r1.Next());
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will produce a better random sequence. The first five numbers here are different from the second five numbers here and this is because we&amp;rsquo;re just using one instance of the random class. If you needed to generate random numbers between method calls then you could have a static random instance that&amp;rsquo;s used by multiple methods.&lt;/p&gt;

&lt;h3 id=&#34;using-tuples-to-reduce-code:644a264f609cf3d22e9b5a9bc20636f4&#34;&gt;Using Tuples to reduce code&lt;/h3&gt;

&lt;p&gt;Tuples are generic classes that we can use to hold sets of values of potentially different types. There&amp;rsquo;s a couple of different ways we can create tuples. The first is to simply use the constructor. Below I&amp;rsquo;m creating a single element tuple using the new keyword specifying the type of int and giving it a value for the int.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var tupleOneElement = new Tuple&amp;lt;int&amp;gt;(1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can create TwoElement versions. Below is an int and a string&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var tupleTwoElement = new Tuple&amp;lt;int, string&amp;gt;(1, &amp;quot;hello&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and we can keep going all the way up to seven elements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var tupleSevenElement = 
            new Tuple&amp;lt;int, int, int, int, int, int, int&amp;gt;(1, 2, 3, 4, 5, 6, 7);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to hold more than seven elements, we can do this, but the eighth element must be a tuple. Below is 8 elements, 1-7 with the eighth element being its own tuple and we can continue to nest these.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  var tupleEightElement =new Tuple&amp;lt;int, int, int, int, int, int, int, Tuple&amp;lt;string&amp;gt;&amp;gt;(1, 2, 3, 4, 5, 6, 7, new Tuple&amp;lt;string&amp;gt;(&amp;quot;hello&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The static Create method can be used to create Tuples. The Create method takes a list of values. Below we&amp;rsquo;re creating a tuple with an integer, a string, and a DateTime.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var tupleThreeElement = Tuple.Create(42, &amp;quot;hello&amp;quot;, DateTime.Now);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we&amp;rsquo;ve created a tuple, we can access its properties using the .item1 or .item2 properties. If we created a 7 element tuple, we&amp;rsquo;d have item1 through to item7.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        var t = Tuple.Create(42, &amp;quot;hello&amp;quot;);

        int age = t.Item1;
        string greeting = t.Item2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we create a tuple, we can&amp;rsquo;t then change the values of the elements as tuples are immutable.&lt;/p&gt;

&lt;p&gt;We can compare tuples. Below are 2 tuples with the same values, 42 and hello.
 var t1 = Tuple.Create(42, &amp;ldquo;hello&amp;rdquo;);
            var t2 = Tuple.Create(42, &amp;ldquo;hello&amp;rdquo;);
If we use the standard == operator, we get a reference comparison. So, isEqualTuples in this instance will be false as the variable t1 doesn&amp;rsquo;t refer to the same thing as the variable t2.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        // Reference equality
        var isEqualTuples = t1 == t2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to get a value comparison, we can just use the Equals method. This will compare each individual element within each tuple.&lt;/p&gt;

&lt;p&gt;// &amp;ldquo;value&amp;rdquo; comparison
            isEqualTuples = t1.Equals(t2);&lt;/p&gt;

&lt;p&gt;A good use of tuples is to allow us to create composite keys in dictionaries. Below are three tuples and a SortedDictionary.&lt;/p&gt;

&lt;p&gt;var t1 = Tuple.Create(1, &amp;ldquo;z&amp;rdquo;);
   var t2 = Tuple.Create(2, &amp;ldquo;a&amp;rdquo;);
   var t3 = Tuple.Create(1, &amp;ldquo;a&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;var d = new SortedDictionary&lt;Tuple&lt;int, string&gt;, string&amp;gt;();&lt;/p&gt;

&lt;p&gt;The key in the dictionary is a tuple of int, string and the value in the dictionary is just a string. We then add our three tuples&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;d.Add(t1, &amp;quot;this is Tuple t1&amp;quot;);
d.Add(t2, &amp;quot;this is Tuple t2&amp;quot;);
d.Add(t3, &amp;quot;this is Tuple t3&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tuples appear in their sorted order. When sorting tuples, the first element is compared. If they are different, then that gives us our sort order. However, if they&amp;rsquo;re the same, then we compare the next element in the tuple. If these are the same, then we&amp;rsquo;d compare the next, and so on.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SOLID Principles</title>
      <link>http://sh33tal.github.io/post/Solid-Principles/</link>
      <pubDate>Sun, 02 Nov 2014 09:14:00 -0700</pubDate>
      
      <guid>http://sh33tal.github.io/post/Solid-Principles/</guid>
      <description>

&lt;p&gt;Having been a database developer I was accustomed to programming in a procedural languages. When I took up programming in C# I was never sure how good Object Orientated code should look. I could get the job done but was my code easy to maintain, flexible for change and so on? I was pointed to the SOLID principles. I found these principles particular useful as my team are TDD evangelists. I am going to share my learning in this blog.&lt;/p&gt;

&lt;h3 id=&#34;the-single-responsibility-principle:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;The Single Responsibility Principle&lt;/h3&gt;

&lt;p&gt;This represents the &amp;ldquo;S&amp;rdquo; in Solid.&lt;/p&gt;

&lt;h4 id=&#34;definition:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Definition&lt;/h4&gt;

&lt;p&gt;The Single Responsibility Principle states that every object should have a single responsibility, and that responsibility should be entirely encapsulated by the class. My Interpretation of this is there should never be more than one reason for a class to change. Just because you can doesn&amp;rsquo;t mean you should. This relates to the concepts of Cohesion and Coupling. We want to strive for cohesion, but also for loose coupling. So cohesion is basically how strongly related and focused the various responsibilities in a module or class are. And coupling is defined as the degree to which each program module or class relies on each of the other modules. We should strive for low coupling, but high cohesion.&lt;/p&gt;

&lt;h4 id=&#34;responsibilities:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Responsibilities&lt;/h4&gt;

&lt;p&gt;Requirements changes typically map to responsibilities. The more responsibilities a class has, the more likelihood of change. Having multiple responsibilities within a class couples together these responsibilities making it likely that changes in one responsibility will effect or break features that are the other responsibilities of a class. The more classes a change effects, the more likely the change will introduce errors into our system. Thus it&amp;rsquo;s important to try and craft our classes in such a way that the areas that are most likely to change are encapsulated into separate classes with single responsibilities.&lt;/p&gt;

&lt;h3 id=&#34;the-open-closed-principle:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;The Open / Closed Principle&lt;/h3&gt;

&lt;p&gt;The Open/Closed Principle, which represents the &amp;ldquo;O&amp;rdquo; in the solid.
This states that software entities such as classes, modules, functions, etc should be open for extension, but closed for modification. When you extend your software you should not need to go and dig around in its internals just to change its behavior. You should be able to extend it by adding new functionality with new classes, new functions. Without the need to change your existing classes and functions, while still achieving new behavior. That means you shouldn&amp;rsquo;t need to change the source code or the binary code, you shouldn&amp;rsquo;t have to recompile the existing pieces of your application a necessarily to achieve this.
How do we change behavior without changing code? The key is to rely on abstractions. Once we start to rely on abstractions in our code, there is no limit to the number of different ways we can implement that abstraction, and thus no limit to the number of ways we can change the behavior of the code that&amp;rsquo;s using these abstractions. So what do we mean by abstractions? Abstractions include Interfaces, as well as Abstract Base Classes.&lt;/p&gt;

&lt;h3 id=&#34;the-liskov-substitution-principle:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;The Liskov Substitution Principle&lt;/h3&gt;

&lt;p&gt;The &amp;ldquo;L&amp;rdquo; in the solid principles of object oriented development.
This Principle simply states that subtypes must be substitutable for their base types. In general calling code should not know that there is any difference at all between a derived type and its base type.  It&amp;rsquo;s very common to say that a particular class IS-A whatever base class it is, for example one might have an employee class that IS-A contact, that IS-A person, or you might have a square that IS-A shape, or a car that IS-A vehicle. The Liskov Substitution Principle suggests that rather than simply considering whether or not some noun is another noun, you should instead consider whether or not it is substitutable for, that other noun in all situations where one might expect it to be. Invariants are things that have to do with the integrity of your model that your classes represent. So they consist of reasonable assumptions of behavior by clients and by other classes that make use of your class. Frequently unit tests can be used to identify what the expected behavior is, for a given method or class. And these unit tests should fail if that behavior is broken or changed, by a subtype that violates it.
Conforming to the Liskov Substitution Principle allows you to properly use polymorphism in your application and will produce more maintainable code. You should remember that is-substitutable-for is the preferred relationship that you should be looking at when you consider inheritance. Rather than simply that IS-A relationship that&amp;rsquo;s so commonly used.&lt;/p&gt;

&lt;h3 id=&#34;the-interface-segregation-principle:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;The Interface Segregation Principle&lt;/h3&gt;

&lt;p&gt;This represents the letter &amp;ldquo;I&amp;rdquo; in the solid acronym of Principles of object oriented design. And applying it can help you create projects and applications that have fewer hidden dependencies, and are more cohesive and easier to maintain. The Interface Segregation Principle basically states, that clients should not be forced to depend on methods that they do not use. You should prefer small cohesive interfaces, to fat interfaces.
It&amp;rsquo;s important for us to further define what we mean by an Interface. An Interface represents a non implementable type that specifies a public set of methods and properties, that must be implemented by anything that chooses to implement that interface. However it&amp;rsquo;s also the public interface of a class, so any class, any type, whatever it&amp;rsquo;s public interface is, whatever its public methods and properties are, if these are things that are used by some client, and it only requires the use of some small subset of those things, it&amp;rsquo;s possible that you would end up with a better design if you were to segregate that class in some way that makes the client not need to use as much of it.&lt;/p&gt;

&lt;h4 id=&#34;design-smells-and-tips:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Design Smells and Tips&lt;/h4&gt;

&lt;p&gt;So some of the smells that you should be looking for in your code that indicate you might be violating the Interface Segregation Principle include, unimplemented interface methods, whether it&amp;rsquo;s in abstract class or any type of base class, or an actual interface, if you find in your code things where your overriding methods from your base class or your base interface, and then simply throwing a new non implemented exception or doing some other kind of degenerate implementation. You should realize that this is probably violating ISP because clearly the class that&amp;rsquo;s using this implementation is not using this particular method, and therefore its using a smaller subset of the actual interface that&amp;rsquo;s its being forced to depend upon. These violate the Liskov Substitution Principle because now these derived classes will not be substitutable for their base classes when the clients expect for all of these interfaces, the entire interface to be implemented and all the methods to do something useful.
Another smell is when you have a client that references a class, but it only uses a small portion of it. This is very similar to the last smell, but not quite exactly the same. This is more from the client side rather than from the implementation side, when you see this sometimes you can make a facade or some other kind of class, that your class depends on and that makes it so that your not depending upon the larger class which is perhaps more likely to change and break your class. When should we fix violations of the Interface Segregation Principle? Like most of these principles you really only want to address them if there&amp;rsquo;s pain, if there&amp;rsquo;s no pain then there&amp;rsquo;s not really a problem that needs to be attended to and you should continue adding new features, and fixing bugs and generally adding value to your application. However if you find yourself depending on a fat interface that you own and this is causing problems because of the dependencies involved, the best thing to do is create a smaller interface that has just what the client needs, have the fat interface implement this new interface. And then reference the new interface within your client code, ignoring the fat interface now. If you find fat interfaces are problematic, but you don&amp;rsquo;t own them, something that you can do is create a smaller interface with just what you need, and then implement this interface.
So some basic tips for the Interface Segregation Principle, keep your interfaces small, cohesive, and focused. Whenever possible you want to let the client define the interface, because this will ensure that the interface really only includes what the client needs. And also whenever possible package the interface with the client. Alternately you can package the interface in a third assembly that both the client and implementation depend upon, and only as a last resort should you try and package up interfaces with their implementation.&lt;/p&gt;

&lt;p&gt;In summary The Interface Segregation Principle states that you should not force client code to depend on things that it doesn&amp;rsquo;t need. You want to make sure you keep your interfaces lean and focused. Refactor large interfaces so they inherit from smaller interfaces that your client uses.&lt;/p&gt;

&lt;h3 id=&#34;the-dependency-inversion-principle:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;The Dependency Inversion Principle&lt;/h3&gt;

&lt;p&gt;The D in the solid principles of object-oriented design. The Dependency Inversion Principle is one of the most important principles of building object-oriented software&lt;/p&gt;

&lt;h4 id=&#34;definition-1:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Definition&lt;/h4&gt;

&lt;p&gt;So the Dependency Inversion Principle states that high-level modules should not depend on low-level modules. Both should depend on abstractions. Furthermore, abstractions should not depend on details, but rather details should depend on abstractions.&lt;/p&gt;

&lt;h4 id=&#34;what-are-dependencies:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;What are Dependencies&lt;/h4&gt;

&lt;p&gt;If you&amp;rsquo;re writing .net software you have taken a dependency on the .net platform, the .net framework, and more or less on Windows. It&amp;rsquo;s a dependency that you&amp;rsquo;re probably pretty comfortable with and that you don&amp;rsquo;t expect to change too much with the course of your software. However, the dependencies we&amp;rsquo;re talking about with regard to our application design are more low level and things that we are going to expect to possibly change as part of our application during its lifetime. For example, access to Third Party Libraries. These can often be things that will change frequently and, therefore, if possible we want to be able to inject alternate implementations of these Third Party Libraries into our code, unless we&amp;rsquo;re certain that our choice of Third Party Libraries is not like to change for the lifetime of our application. Certainly, our database represents a dependency assuming that our application has one and it&amp;rsquo;s definitely one of the things that you will want to wrap in such a way that it is not an implicit dependency within your code, but rather something that could be injected and replaced. We&amp;rsquo;ll see more about how to do that soon. Other dependencies are less obvious. For example, if your code references the file system, if it uses email, if it sends email or even checks email from a POP mailbox for example, if it uses Web Services or really any kind of network access at all, would be a dependency as well. Now represent further dependencies that might require you to invert in the case of situations where they affect the behavior of your application and there&amp;rsquo;s no way for you to test it unless you run it at certain times of day. Configuration can be a dependency in terms of the files that you use for configuring your application. The new Keyword is itself a possible indication that you&amp;rsquo;ve got a dependency within your application. You want to limit the places in which you allow your application to instantiate new objects, unless they&amp;rsquo;re primitives like strings, for example. And related to that is the use of static methods. Anytime you&amp;rsquo;re calling a static method, you&amp;rsquo;re adding a dependency to your code that cannot easily be separated from the calling code in the case of trying to write a test for it or in the case of wanting to change the way your code works throughout the entire application in one place. If you have static methods sprinkled throughout your code, it&amp;rsquo;s very difficult to change them all through one configuration change or one startup file change. Thread.Sleep can also be a dependency, as well as the use of Random, and it can be very difficult to test code that is supposed to give you random results, so if you specify an interface that you use for generating your random values, then in your test you can override that interface and say, well if the random value is this, then I should expect this result and similarly it allows you to more easily test so-called random data. These are some of the dependencies that you should be aware of. It&amp;rsquo;s certainly not an exhaustive list.&lt;/p&gt;

&lt;h4 id=&#34;traditional-programming:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Traditional Programming&lt;/h4&gt;

&lt;p&gt;Most traditional programming works in such a way that dependencies naturally accrue within the code because the higher-level modules tend to call the lower-level modules and by calling them they also tend to instantiate them as they need them, so it&amp;rsquo;s very typical for you to have, for instance, a user interface application that references some business logic and it might new-up one of those business logic classes, perhaps a customer class or an order class, and do some work with it. And in the course of calling the methods on that class maybe it has to talk to the database or maybe it has to talk to some other sort of infrastructure. Typically that business logic class would then new-up a Data Access component or a logger component or some other kind of class to do its work, and so ultimately, the user interface is depending on the business logic, the business logic is depending on the infrastructure and utility in the Data Access classes. Furthermore, it&amp;rsquo;s often the case that a facade layer is implemented using static methods in order to facilitate a simpler API for those business level methods. Then finally, it&amp;rsquo;s typical that class instantiation and call stack logic is scattered throughout the application. This violates the Single Responsibility Principle because now every class that is deciding who it&amp;rsquo;s collaborators are through the use of static methods or the new keyword to instantiate specific instances with which it wants to work, is now responsible not just for its actual work, but also for determining who it&amp;rsquo;s working with, and these are actually separate responsibilities that the Single Responsibility Principle should dictate that you would want to put into separate classes.&lt;/p&gt;

&lt;h4 id=&#34;class-dependencies:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Class Dependencies&lt;/h4&gt;

&lt;p&gt;When we&amp;rsquo;re talking about class dependencies, our class constructor should require any dependencies that the class actually needs. Classes whose constructors make this very clear have what I would call explicit dependencies, however, classes that do not make this clear have implicit or hidden dependencies. They&amp;rsquo;re lying to you. When they say that you can just new them up without passing them anything, but then they don&amp;rsquo;t work if the database isn&amp;rsquo;t there, that&amp;rsquo;s telling you something that is false. It&amp;rsquo;s telling you that this class would work, but then it&amp;rsquo;s not letting you know about the fact you actually need a database in order to do anything.&lt;/p&gt;

&lt;h4 id=&#34;design-smells:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Design Smells&lt;/h4&gt;

&lt;p&gt;Now let&amp;rsquo;s take a look at some design smells related to the Dependency Inversion Principle. The first one is the simplest, it&amp;rsquo;s simply the use of the new keyword. If you find in your code that you&amp;rsquo;re using the new keyword and newing up actual instantiations of particular instances of classes, rather than interfaces, it&amp;rsquo;s often a sign that you could apply the Dependency Inversion Principle.
Similar to the use of the new keyword is the use of static methods or properties. This can be something as simple as a DateTime.Now that&amp;rsquo;s crept into your code instead of having an actual DateTime passed in or an abstraction such as an iCalendar or an iDateTime interface that supports the Now method that you want to be able to pass in.
The one place where you should use or could use static methods is when they don&amp;rsquo;t actually touch anything other than the parameters that are passed into them. For example, if you had a static method that added two numbers together and it took in those numbers as parameters, there would be no problem with that because it&amp;rsquo;s not going to cause any sort of a dependency problem, but if you have a static method that instantiates other classes and those classes might have dependencies of their own, now that&amp;rsquo;s something that is going to likely cause you problems when it comes time to test.&lt;/p&gt;

&lt;h4 id=&#34;where-to-instantiate:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Where to Instantiate&lt;/h4&gt;

&lt;p&gt;If we&amp;rsquo;re not instantiating our objects, where do we insatiate them, you know, somewhere we have to do this. So typically what happens when you apply Dependency Injection is you get many small interfaces, which is good, because each one of them is very cohesive, they&amp;rsquo;re loosely coupled to one another, they have the Single Responsibility Principle, they follow the Interface Segregation Principle, but at some point you have to actually create these objects. There&amp;rsquo;s a couple of different choices for this.
The first one is you can create a default constructor that then inherits from your constructor that actually takes in the interfaces and provides a default implementation of each of those interfaces. This is sometimes poor man&amp;rsquo;s dependency injection or poor man&amp;rsquo;s IoC. IoC means Inversion of Control. The other option is to manually instantiate everything in your application startup routine or main() method. In a web app this could be an application start in the global.asax and another option is to use an IoC container, which does the same thing typically in the main or startup method, but it has a bunch of features that it supports so that you can wire these things up in an intelligent fashion and go to one place and see how your object graph is going to be set up for your application.&lt;/p&gt;

&lt;h4 id=&#34;ioc-containers:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;IoC Containers&lt;/h4&gt;

&lt;p&gt;So, IoC containers or Inversion of Control Containers are responsible for object graph instantiation. They&amp;rsquo;re initiated when the application begins and typically they either use code or configuration, such as an XML file to determine what is going to be set up to be used whenever an interface is called for. Managed interfaces and implementations to be used are registered with the container, so for instance, you might have in your container something that says you want to register IPrintService and say that anywhere I see an object that requires IPrintService, I want to use a new instance of PrintService. Dependencies on these interfaces are then resolved either at application startup or at runtime. You can call an IoC Resolve method that will go and find whatever the instance is that&amp;rsquo;s mapped to that interface at runtime or you can have a container that automatically is able to create the dependency graph for a given class by using its constructor. Typically the constructor that has the most parameters is the one that we&amp;rsquo;ll use.
Sometimes it&amp;rsquo;s necessary to create a factory class that is able to create your class for you and then register the factory class and its dependencies with your IoC Container.&lt;/p&gt;

&lt;h4 id=&#34;interested-in-more-here-are-more-great-resources:eb77c95d8ae22b8fdfb4ecb24c6cc8b5&#34;&gt;Interested in more? Here are more great resources&lt;/h4&gt;

&lt;p&gt;Agile Principles, Patterns, and Practices book by Robert C. Martin and Micah Martin [&lt;a href=&#34;http://amzn.to/agilepppcsharp&#34;&gt;http://amzn.to/agilepppcsharp&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Martin Fowler&amp;rsquo;s article on dependency injection
&lt;a href=&#34;http://www.martinfowler.com/articles/injection.html&#34;&gt;http://www.martinfowler.com/articles/injection.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>